---
outline: deep
---

# TypeScript 简介

TypeScript 是带有类型语法的 JavaScript。

TypeScript 提供了 JavaScript 的所有功能，并在这些特性之上增加了一层：TypeScript 的类型系统。

# 快速入门

## 定义类型

TypeScript 代码最明显的特征，就是为 JavaScript 变量加上了类型声明。

```ts
let s: string = "hello";
```

## 类型推断

类型声明并不是必需的，如果没有，TypeScript 会自己推断类型。

## TypeScript 的编译

## 值与类型

## tsc 编译器

```powershell
tsc --init
```

## ts-node 模块

```powershell
npm i ts-node
```

# 特殊类型

一旦设为 any，TypeScript 实际上会关闭这个变量的类型检查。即使有明显的类型错误，只要句法正确，都不会报错。

## any

> any 类型表示没有任何限制，该类型的变量可以赋予任意类型的值。

```ts
let x: any;

x = 1; // 正确
x = "foo"; // 正确
x = true; // 正确
```

**变量类型一旦设为 any，TypeScript 实际上会关闭这个变量的类型检查**。即使有明显的类型错误，只要句法正确，都不会报错。

```ts
let x: any = "hello";

x(1); // 不报错
x.foo = 100; // 不报错
```

从集合论的角度看，`any`类型可以看成是所有其他类型的全集，包含了一切可能的类型。TypeScript 将这种类型称为“顶层类型”（top type），意为涵盖了所有下层

### 类型推断

对于开发者没有指定类型、TypeScript 必须自己推断类型的那些变量，如果无法推断出类型，TypeScript 就会认为该变量的类型是`any`。

### 变量污染

any 类型会“污染”其他变量。它可以赋值给其他任何类型的变量（因为没有类型检查），导致其他变量出错

```ts
let x: any = "hello";
let y: number;

y = x; // 不报错

y * 123; // 不报错
y.toFixed(); // 不报错
```

污染其他具有正确类型的变量，把错误留到运行时，这就是不宜使用`any`类型的另一个主要原因。

## unknown

为了解决`any`类型“污染”其他变量的问题，TypeScript 3.0 引入了[`unknown`类型](https://www.typescriptlang.org/docs/handbook/release-notes/typescript-3-0.html#new-unknown-top-type)。它与`any`含义相同，**表示类型不确定**，可能是任意类型，但是它的使用有一些限制，不像`any`那样自由，可以视为严格版的`any`。

在集合论上，`unknown`也可以视为所有其他类型（除了`any`）的全集，所以它和`any`一样，也属于 TypeScript 的顶层类型

- `unknown`跟`any`的相似之处，在于所有类型的值都可以分配给`unknown`类型

```ts
let x: unknown;

x = true; // 正确
x = 42; // 正确
x = "Hello World"; // 正确
```

- `unknown`类型跟`any`类型的不同之处在于，它不能直接使用

  - `unknown`类型的变量，不能直接赋值给其他类型的变量

  ```ts
  let v: unknown = 123;

  let v1: boolean = v; // 报错
  let v2: number = v; // 报错
  ```

  - 不能直接调用`unknown`类型变量的方法和属性

    ```ts
    let v1: unknown = { foo: 123 };
    v1.foo; // 报错

    let v2: unknown = "hello";
    v2.trim(); // 报错

    let v3: unknown = (n = 0) => n + 1;
    v3(); // 报错
    ```

  - `unknown`类型变量能够进行的运算是有限的，只能进行比较运算（运算符`==`、`===`、`!=`、`!==`、`||`、`&&`、`?`）、取反运算（运算符`!`）、`typeof`运算符和`instanceof`运算符这几种，其他运算都会报错

    ```ts
    let a: unknown = 1;

    a + 1; // 报错
    a === 1; // 正确
    ```

  使用`unknown`类型变量，需要经过“类型缩小”，`unknown`类型变量才可以使用

  ```ts
  let a: unknown = 1;

  if (typeof a === "number") {
    let r = a + 10; // 正确
  }
  let s: unknown = "hello";

  if (typeof s === "string") {
    s.length; // 正确
  }
  ```

- `unknown`类型的变量，不能直接赋值给其他类型的变量（除了`any`类型和`unknown`类型）。

```ts
let v: unknown = 123;

let v1: boolean = v; // 报错
let v2: number = v; // 报错
```

## never

TypeScript 还引入了“空类型”的概念，即该类型为空，不包含任何值。

由于不存在任何属于“空类型”的值，所以该类型被称为`never`，即不可能有这样的值。

```ts
function fn(x: string | number) {
  if (typeof x === "string") {
    // ...
  } else if (typeof x === "number") {
    // ...
  } else {
    x; // never 类型
  }
}
```

- `never`类型的一个重要特点是，可以赋值给任意其他类型

空集是任何集合的子集。TypeScript 就相应规定，任何类型都包含了`never`类型。因此，`never`类型是任何其他类型所共有的，TypeScript 把这种情况称为“底层类型”（bottom type）。

```ts
function f(): never {
  throw new Error("Error");
}

function g(): never {
  g();
}

let v1: number = f(); // 不报错
let v2: string = f(); // 不报错
let v3: boolean = g(); // 不报错
```

# 类型系统

## 基本类型

## 值类型

TypeScript 规定，单个值也是一种类型，称为“值类型”。
变量 x 的类型是字符串 hello，导致它只能赋值为这个字符串，赋值为其他字符串就会报错。

```ts
let x: "hello";

x = "hello"; // 正确
x = "world"; // 报错
```

TypeScript 推断类型时，遇到 const 命令声明的变量，如果代码里面没有注明类型，就会推断该变量是值类型。

```ts
// x 的类型是 "https"
const x = "https";

// y 的类型是 string
const y: string = "https";
```

const 命令声明的变量，如果赋值为对象，并不会推断为值类型

```ts
// x 的类型是 { foo: number }
const x = { foo: 1 };
```

## 联合类型

联合类型（union types）指的是多个类型组成的一个新类型，使用符号|表示。

联合类型 A|B 表示，任何一个类型只要属于 A 或 B，就属于联合类型 A|B。

变量 x 就是联合类型 string|number，表示它的值既可以是字符串，也可以是数值。

```ts
let x: string | number;
x = 123; // 正确
x = "abc"; // 正确
```

- 联合类型可以与值类型相结合，表示一个变量的值有若干种可能

```ts
let setting: true | false;
let gender: "male" | "female";
let rainbowColor: "赤" | "橙" | "黄" | "绿" | "青" | "蓝" | "紫";
```

## 交叉类型

> 交叉类型（intersection types）指的多个类型组成的一个新类型，使用符号&表示

交叉类型 A&B 表示，任何一个类型必须同时属于 A 和 B，才属于交叉类型 A&B，即交叉类型同时满足 A 和 B 的特征。

```ts
let x: number & string;
```

上面示例中，变量 x 同时是数值和字符串，这当然是不可能的，所以 TypeScript 会认为 x 的类型实际是 never。

- 交叉类型的主要用途是表示对象的合成。

```ts
let obj: { foo: string } & { bar: string };

obj = {
  foo: "hello",
  bar: "world",
};
```

- 交叉类型常常用来为对象类型添加新属性

```ts
type A = { foo: number };
//类型B是一个交叉类型，用来在A的基础上增加了属性bar
type B = A & { bar: number };`
```

## type 关键字

> 定义类型的别名。

```ts
type Age = number;

let age: Age = 55;
```

- 别名不允许重名

```ts
type Color = "red";
type Color = "blue"; // 报错
```

- 别名的作用域是块级作用域。这意味着，代码块内部定义的别名，影响不到外部。

```ts
type Color = "red";

if (Math.random() < 0.5) {
  type Color = "blue";
}
```

- 别名支持使用表达式，也可以在定义一个别名时，使用另一个别名，即别名允许嵌套。

```ts
type World = "world";
type Greeting = `hello ${World}`;
```

## typeof 操作符

在 JavaScript 中，typeof 运算符是一个一元运算符，返回一个字符串，代表操作数的类型。

JavaScript 里面，typeof 运算符只可能返回八种结果，而且都是字符串。

```ts
typeof undefined; // "undefined"
typeof true; // "boolean"
typeof 1337; // "number"
typeof "foo"; // "string"
typeof {}; // "object"
typeof parseInt; // "function"
typeof Symbol(); // "symbol"
typeof 127n; // "bigint"
```

TypeScript 将 typeof 运算符移植到了类型运算，它的操作数依然是一个值，但是返回的不是字符串，而是该值的 TypeScript 类型。

```ts
const a = { x: 0 };

type T0 = typeof a; // { x: number }
type T1 = typeof a.x; // number
```

JavaScript 的 typeof 遵守 JavaScript 规则，TypeScript 的 typeof 遵守 TypeScript 规则。它们的一个重要区别在于，编译后，前者会保留，后者会被全部删除。

```ts
let a = 1;
let b: typeof a;

if (typeof a === "number") {
  b = a;
}
```

## 块级类型声明

TypeScript 支持块级类型声明，即类型可以声明在代码块（用大括号表示）里面，并且只在当前代码块有效。

```ts
typescript;
if (true) {
  type T = number;
  let v: T = 5;
} else {
  type T = string;
  let v: T = "hello";
}
```

上面示例中，存在两个代码块，其中分别有一个类型 T 的声明。这两个声明都只在自己的代码块内部有效，在代码块外部无效。

## 类型的兼容

TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。

```ts
type T = number | string;

let a: number = 1;
let b: T = a;
```

凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行

```ts
let a: "hi" = "hi";
let b: string = "hello";

b = a; // 正确
a = b; // 报错
```

# 数组

## 两种声明方式

```ts
let arr: number[] = [1, 2, 3];
```

如果数组成员的类型比较复杂，可以写在圆括号里面。

```ts
//圆括号是必须的，否则因为竖杠|的优先级低于[]，TypeScript 会把number|string[]理解成number和string[]的联合类型
let arr: (number | string)[];
```

如果数组成员可以是任意类型

```ts
let arr: any = [];
```

数组类型的第二种写法是使用 TypeScript 内置的 Array 接口。

```ts
let arr: Array<number> = [1, 2, 3];
```

TypeScript 不会对数组边界进行检查，越界访问数组并不会报错。

```ts
let arr: number[] = [1, 2, 3];
let foo = arr[3]; // 正确
```

## 数组的类型推断

```ts
// 推断类型为 number[]
const arr = [123];
arr.push("abc"); // 报错
```

## 只读数组

```ts
const arr: readonly number[] = [0, 1];

arr[1] = 2; // 报错
arr.push(3); // 报错
delete arr[0]; // 报错
```

`readonly`关键字不能与数组的泛型写法一起使用

```ts
// 报错
const arr: readonly Array<number> = [0, 1];
```

```ts
const a1: ReadonlyArray<number> = [0, 1];

const a2: Readonly<number[]> = [0, 1];
```

## const 断言

const 断言声明只读数组

```ts
const arr = [0, 1] as const;

arr[0] = [2]; // 报错
```

## 多维数组

TypeScript 使用 `T[][]`的形式，表示二维数组，`T[][]` 是最底层数组成员的类型。

```ts
var multi: number[][] = [
  [1, 2, 3],
  [23, 24, 25],
];
```

上面示例中，变量 multi 的类型是 number[][]，表示它是一个二维数组，最底层的数组成员类型是 number。

# 元组

> 成员类型可以自由设置的数组，即数组的各个成员的类型可以不同

**元组必须明确声明每个成员的类型**

```ts
const s: [string, string, boolean] = ["a", "b", true];
```

上面示例中，元组 s 的前两个成员的类型是 string，最后一个成员的类型是 boolean。

使用元组时，必须明确给出类型声明（上例的[number]），不能省略，否则 TypeScript 会把一个值自动推断为数组。

```ts
// a 的类型为 (number | boolean)[]
let a = [1, true];
```

元组成员的类型可以添加问号后缀（`?`），表示该成员是可选的。

```ts
let a: [number, number?] = [1];
```

所有可选成员必须在必选成员之后

```ts
type myTuple = [number, number, number?, string?];
```

## 只读元组

元组也可以是只读的，不允许修改

```ts
// 写法一
type t = readonly [number, string];

// 写法二
type t = Readonly<[number, string]>;
```

跟数组一样，只读元组是元组的父类型。所以，元组可以替代只读元组，而只读元组不能替代元组。

```ts
type t1 = readonly [number, number];
type t2 = [number, number];

let x: t2 = [1, 2];
let y: t1 = x; // 正确

x = y; // 报错
```

```ts
function distanceFromOrigin([x, y]: [number, number]) {
  return Math.sqrt(x ** 2 + y ** 2);
}

let point = [3, 4] as const;

distanceFromOrigin(point); // 报错
distanceFromOrigin(point as [number, number]); //将传入的参数断言为普通元组
```

# 函数

# 对象

# 接口(interface)

interface 是对象的模板，可以看作是一种类型约定。使用了某个模板的对象，就拥有了指定的类型结构。

```ts
interface Person {
  firstName: string;
  lastName: string;
  age: number;
}

const p: Person = {
  firstName: "John",
  lastName: "Smith",
  age: 25,
};
```

TypeScript 的类型存在兼容关系，某些类型可以兼容其他类型。

```ts
type T = number | string;

let a: number = 1;
let b: T = a;
```

变量 a 和 b 的类型是不一样的，但是变量 a 赋值给变量 b 并不会报错。这时，我们就认为，b 的类型兼容 a 的类型。

如果类型 A 的值可以赋值给类型 B，那么类型 A 就称为类型 B 的子类型（subtype）。在上例中，类型 number 就是类型 number|string 的子类型。

**凡是可以使用父类型的地方，都可以使用子类型，但是反过来不行**

```ts
let a: "hi" = "hi";
let b: string = "hello";

b = a; // 正确
a = b; // 报错
```

上面示例中，hi 是 string 的子类型，string 是 hi 的父类型。所以，变量 a 可以赋值给变量 b，但是反过来就会报错。

之所以有这样的规则，是因为子类型继承了父类型的所有特征，所以可以用在父类型的场合。但是，子类型还可能有一些父类型没有的特征，所以父类型不能用在子类型的场合。

## 继承

interface 可以使用`extends`关键字，继承其他 interface

`extends`关键字会从继承的接口里面拷贝属性类型，这样就不必书写重复的属性

```ts
interface Shape {
  name: string;
}

interface Circle extends Shape {
  radius: number;
}

let c: Circle = {
  name: "circle",
  radius: 5,
};
```

interface 允许多重继承

```ts
interface Style {
  color: string;
}

interface Shape {
  name: string;
}

interface Circle extends Style, Shape {
  radius: number;
}

let c: Circle = {
  name: "circle",
  radius: 5,
  color: "pink",
};
```

多重接口继承，实际上相当于多个父接口的合并。

如果子接口与父接口存在同名属性，那么子接口的属性会覆盖父接口的属性。注意，子接口与父接口的同名属性必须是类型兼容的，不能有冲突，否则会报错

```ts
interface Foo {
  id: string;
}

interface Bar extends Foo {
  id: number; // 报错
}
```

多重继承时，如果多个父接口存在同名属性，那么这些同名属性不能有类型冲突，否则会报错。

```ts
interface Foo {
  id: string;
}

interface Bar {
  id: number;
}

// 报错
interface Baz extends Foo, Bar {
  type: string;
}
```

interface 继承 class

```ts
class A {
  x: string = "";

  y(): boolean {
    return true;
  }
}

interface B extends A {
  z: number;
}

const b: B = {
  x: "",
  y: function () {
    return true;
  },
  z: 123,
};
```

## 合并

多个同名接口会合并成一个接口。

```ts
interface Box {
  height: number;
  width: number;
}

interface Box {
  length: number;
}
```

同名接口合并时，同一个属性如果有多个类型声明，彼此不能有类型冲突。

```ts
interface A {
  a: number;
}

interface A {
  a: string; // 报错
}
```

## interface 与 type 的区别

| 特性         | `interface`                | `type`                         |
| :----------- | :------------------------- | :----------------------------- |
| **定义范围** | 仅对象类型                 | 所有类型（对象、联合、元组等） |
| **扩展性**   | `extends` 继承 + 声明合并  | 交叉类型（`&`）                |
| **声明合并** | 支持                       | 不支持                         |
| **典型场景** | 对象结构、类实现、声明合并 | 联合类型、交叉类型、工具类型   |

1.`type`能够表示非对象类型，而`interface`只能表示对象类型（包括数组、函数等）。

2.`interface`可以继承其他类型，`type`不支持继承

3.同名`interface`会自动合并，同名`type`则会报错。TypeScript 不允许使用`type`多次定义同一个类型

```ts
type A = { foo: number }; // 报错
type A = { bar: number }; // 报错
```

作为比较，`interface`则会自动合并

```ts
interface A {
  foo: number;
}
interface A {
  bar: number;
}

const obj: A = {
  foo: 1,
  bar: 1,
};
```

# 类

# 泛型

# 类型断言

> 允许开发者在代码中“断言”某个值的类型，告诉编译器此处的值是什么类型

```ts
type T = "a" | "b" | "c";
let foo = "a";

let bar: T = foo; // 报错
```

string 类型不能赋值给 T 类型，父类型不能赋值给子类型

```ts
type T = "a" | "b" | "c";

let foo = "a";
let bar: T = foo as T; // 正确
```

类型断言有两种语法

```ts
// 语法一：<类型>值
<Type>value;

// 语法二：值 as 类型
value as Type;
```
