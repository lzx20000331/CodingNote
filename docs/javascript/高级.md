---
outline: deep
---

# 高级

## 原型（Prototype）

每个对象都有一个私有属性 prototype 指向另一个名为**原型**的对象

当试图访问一个对象的属性时，它不仅仅在该对象上搜寻，还会搜寻该对象的原型，以及原型的原型，依次层层向上搜索，直到找到一个名字匹配的属性或到达原型链的末尾

```js
const o = {
  a: 1,
  b: 2,
  // __proto__ 设置了 [[Prototype]]。它在这里被指定为另一个对象字面量。
  __proto__: {
    b: 3,
    c: 4,
  },
};

// o.[[Prototype]] 具有属性 b 和 c。
// o.[[Prototype]].[[Prototype]] 是 Object.prototype（我们会在下文解释其含义）。
// 最后，o.[[Prototype]].[[Prototype]].[[Prototype]] 是 null。
// 这是原型链的末尾，值为 null，
// 根据定义，其没有 [[Prototype]]。
// 因此，完整的原型链看起来像这样：
// { a: 1, b: 2 } ---> { b: 3, c: 4 } ---> Object.prototype ---> null

console.log(o.a); // 1
// o 上有自有属性“a”吗？有，且其值为 1。

console.log(o.b); // 2
// o 上有自有属性“b”吗？有，且其值为 2。
// 原型也有“b”属性，但其没有被访问。
// 这被称为属性遮蔽（Property Shadowing）

console.log(o.c); // 4
// o 上有自有属性“c”吗？没有，检查其原型。
// o.[[Prototype]] 上有自有属性“c”吗？有，其值为 4。

console.log(o.d); // undefined
// o 上有自有属性“d”吗？没有，检查其原型。
// o.[[Prototype]] 上有自有属性“d”吗？没有，检查其原型。
// o.[[Prototype]].[[Prototype]] 是 Object.prototype 且
// 其默认没有“d”属性，检查其原型。
// o.[[Prototype]].[[Prototype]].[[Prototype]] 为 null，停止搜索，
// 未找到该属性，返回 undefined。
```

## 闭包（Closure）

闭包指的是那些**引用了另一个函数作用域中变量的函数**，通常是在嵌套函数中实现的

```js
function outerFunction() {
  let outerVariable = "I am outside!";

  function innerFunction() {
    console.log(outerVariable); // 可以访问外部函数的变量
  }

  return innerFunction;
}

const myClosure = outerFunction();
myClosure(); // 输出：I am outside!
```

```js
function createCounter() {
  let count = 0;
  return function () {
    count++;
    return count;
  };
}

const counter = createCounter();
console.log(counter()); // 1
console.log(counter()); // 2
console.log(counter()); // 3
```

```js
function makeAdder(x) {
  return function (y) {
    return x + y;
  };
}

var add5 = makeAdder(5);
var add10 = makeAdder(10);

console.log(add5(2)); // 7
console.log(add10(2)); // 12
```

## 代理(Proxy)

**Proxy** 对象用于创建一个对象的代理，从而实现基本操作的拦截和自定义（如属性查找、赋值、枚举、函数调用等）

```js
let obj = {
  name: "lzx",
  age: 15,
  address: {
    province: "湖北",
    city: "随州",
  },
};
let proxyObj = new Proxy(obj, {
  get(target, property, receiver) {
    console.log("get");
    console.log(target, property, receiver);
    return target[property];
  },
  set(target, property, value, receiver) {
    console.log("set");
    console.log(target, property, value, receiver);
    target[property] = value;
  },
});
console.log(proxyObj.name);
console.log(proxyObj.address);
proxyObj.name = "咕咕";
console.log(proxyObj.name);
console.log(obj.name);
```

## 反射(Reflect)

## 迭代器

迭代器无须了解与其关联的可迭代对象的结构，只需要知道如何取得连续的值。

迭代器提供了一种通用的迭代方式

```js
let arr = [1, 3, 5, 7, 9];
//获取迭代器
let iter = arr[Symbol.iterator]();

console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
console.log(iter.next());
```

## 生成器

生成器是 ES6 新增的一个极为灵活的结构，拥有**在一个函数块内暂停和恢复代码执行**的
能力

```js
// 生成器函数声明
function* generatorFn() {}
// 生成器函数表达式
let generatorFn = function* () {};
// 作为对象字面量方法的生成器函数
let foo = {
  *generatorFn() {},
};
// 作为类实例方法的生成器函数
class Foo {
  *generatorFn() {}
}
// 作为类静态方法的生成器函数
class Bar {
  static *generatorFn() {}
}
```

箭头函数不能用来定义生成器函数

## Promise

ECMAScript 6 新增的引用类型 Promise，可以通过 new 操作符来实例化。创建新的 Promise 需要传入执行器（executor）函数作为参数

```js
let p = new Promise(() => {}); //Promise <pending>
```

Promise 是一个有状态的对象，可能处于如下 3 种状态之一：

- 待定（pending）
- 兑现（fulfilled，有时候也称为“解决”，resolved）
- 拒绝（rejected）

待定（pending）是 Promise 的最初始状态。在待定状态下，Promise 可以落定（settled）为代表成功的兑现
（fulfilled）状态，或者代表失败的拒绝（rejected）状态。无论落定为哪种**状态都是不可逆的**

```
let p = new Promise(() => {});
setTimeout(console.log, 0, p); // Promise <pending>
```

## async await

```

```
