很多面向对象语言都支持两种继承：接口继承和实现继承。
前者只继承方法签名，后者继承实际的方法

接口继承在ECMAScript 中是不可能的，因为函数没有签名。实现继承是ECMAScript 唯一支持的继承方式，而这主要是通过原型链实现的。




## 8.3.1 原型链

> 让子类构造函数的原型指向父类实例

构造函数、原型和实例的关系：每个构造函数都有一个原型对象，原型有一个属性指回构造函数，而实例有一个内部指针指向原型

如果原型是另一个类型的实例呢？那就意味着这个原型本身有一个内部指针指向另一个原型，相应地另一个原型也有一个指针指向另一个构造函数。这样就在实例和原型之间构造了一条原型链



```js
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
};
function SubType() {
    this.subproperty = false;
}
// 继承SuperType
SubType.prototype = new SuperType();
SubType.prototype.getSubValue = function () {
    return this.subproperty;
};
let instance = new SubType();
console.log(instance.getSuperValue()); // true
```





### 默认原型

所有引用类型都继承自Object。**任何函数的默认原型都是一个Object 的实例，这意味着这个实例有一个内部指针指向
Object.prototype**。

```js
function Person(name, age) {
    this.name = name;
    this.age = age;
}
let p = new Person("tom", 22);
console.log(p);
while (p != null) {
    p = Object.getPrototypeOf(p);
    console.log(p, p == Person.prototype, p === Object.prototype);
}
```









### 原型与继承关系

原型与实例的关系可以通过两种方式来确定。第一种方式是使用instanceof 操作符，如果一个实
例的原型链中出现过相应的构造函数，则instanceof 返回true



```js
console.log(instance instanceof Object); // true
console.log(instance instanceof SuperType); // true
console.log(instance instanceof SubType); // true
```



确定这种关系的第二种方式是使用isPrototypeOf()方法。原型链中的每个原型都可以调用这个
方法，如下例所示，只要原型链中包含这个原型，这个方法就返回true：

```js
console.log(Object.prototype.isPrototypeOf(instance)); // true
console.log(SuperType.prototype.isPrototypeOf(instance)); // true
console.log(SubType.prototype.isPrototypeOf(instance)); // true
```



### 关于方法



子类有时候需要覆盖父类的方法，或者增加父类没有的方法。为此，这些方法必须在原型赋值之后
再添加到原型上。来看下面的例子：

```js
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
};
function SubType() {
    this.subproperty = false;
}
// 继承SuperType
SubType.prototype = new SuperType();
// 新方法
SubType.prototype.getSubValue = function () {
    return this.subproperty;
};
// 覆盖已有的方法
SubType.prototype.getSuperValue = function () {
    return false;
};
let instance = new SubType();
console.log(instance.getSuperValue()); // false
```



以对象字面量方式创建原型方法会破坏之前的原型链，因为这相当于重写
了原型链。



```js
function SuperType() {
    this.property = true;
}
SuperType.prototype.getSuperValue = function() {
    return this.property;
};
function SubType() {
    this.subproperty = false;
}

// 继承SuperType
SubType.prototype = new SuperType();
// SubType的原型指向了新的对象
SubType.prototype = {
    getSubValue() {
        return this.subproperty;
    },
    someOtherMethod() {
        return false;
    }
};
let instance = new SubType();
console.log(instance.getSuperValue()); // 出错！
```



子类的原型在被赋值为SuperType 的实例后，又被一个对象字面量覆盖了。覆盖
后的原型是一个Object 的实例，而不再是SuperType 的实例。因此之前的原型链就断了。SubType
和SuperType 之间也没有关系了。







### 原型链的问题



- 原型中包含的引用值会在所有实例间共享

原型链虽然是实现继承的强大工具，但它也有问题。主要问题出现在原型中包含引用值的时候。前
面在谈到原型的问题时也提到过，原型中包含的引用值会在所有实例间共享，这也是为什么属性通常会
在构造函数中定义而不会定义在原型上的原因。在使用原型实现继承时，原型实际上变成了另一个类型
的实例。这意味着原先的实例属性摇身一变成为了原型属性。下面的例子揭示了这个问题：



```JS
function SuperType() {
this.colors = ["red", "blue", "green"];
}
function SubType() {}
// 继承SuperType
SubType.prototype = new SuperType();
let instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors); // "red,blue,green,black"
let instance2 = new SubType();
console.log(instance2.colors); // "red,blue,green,black"
```



在这个例子中，SuperType 构造函数定义了一个colors 属性，其中包含一个数组（引用值）。每
个SuperType 的实例都会有自己的colors 属性，包含自己的数组。但是，当SubType 通过原型继承
SuperType 后，SubType.prototype 变成了SuperType 的一个实例，因而也获得了自己的colors
属性。这类似于创建了SubType.prototype.colors 属性。最终结果是，SubType 的所有实例都会
共享这个colors 属性。这一点通过instance1.colors 上的修改也能反映到instance2.colors
上就可以看出来。



- 子类型在实例化时不能给父类型的构造函数传参

原型链的第二个问题是，子类型在实例化时不能给父类型的构造函数传参。事实上，我们无法在不
影响所有对象实例的情况下把参数传进父类的构造函数。再加上之前提到的原型中包含引用值的问题，
就导致原型链基本不会被单独使用。





## 8.3.2 盗用构造函数

为了解决原型包含引用值导致的继承问题，在子类构造函数中调用父类构造函数

```js
function SuperType() {
    this.colors = ["red", "blue", "green"];
}
function SubType() {
    // 继承SuperType
    SuperType.call(this);
}
let instance1 = new SubType();
instance1.colors.push("black");
console.log(instance1.colors); // "red,blue,green,black"
let instance2 = new SubType();
console.log(instance2.colors); // "red,blue,green"
```

通过使用call()（或apply()）方法，SuperType构造函数在为SubType 的实例创建的新对象的上下文中执行了。这相当于新的SubType 对象上运行了SuperType()函数中的所有初始化代码。结果就是每个实例都会有自己的colors 属性。



### 1.传递参数

相比于使用原型链，盗用构造函数的一个优点就是**可以在子类构造函数中向父类构造函数传参**。

```js
function SuperType(name){
    this.name = name;
}
function SubType() {
    // 继承SuperType 并传参
    SuperType.call(this, "Nicholas");
    // 实例属性
    this.age = 29;
}
let instance = new SubType();
console.log(instance.name); // "Nicholas";
console.log(instance.age); // 29
```



### 2.盗用构造函数的问题

盗用构造函数的主要缺点，也是使用构造函数模式自定义类型的问题：**必须在构造函数中定义方法。因此函数不能重用**。此外，**子类也不能访问父类原型上定义的方法**，因此所有类型只能使用构造函数模式。由于存在这些问题，盗用构造函数基本上也不能单独使用。



## 8.3.3 组合继承





**使用原型链继承原型上的属性和方法，而通过盗用构造函数继承实例属性**。这样既可以把方
法定义在原型上以实现重用，又可以让每个实例都有自己的属性。



```js
function SuperType(name){
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function() {
    console.log(this.name);
};
function SubType(name, age){
    // 继承属性
    SuperType.call(this, name);
    this.age = age;
}
// 继承方法
SubType.prototype = new SuperType();
SubType.prototype.sayAge = function() {
    console.log(this.age);
};
let instance1 = new SubType("Nicholas", 29);
instance1.colors.push("black");
console.log(instance1.colors); // "red,blue,green,black"
instance1.sayName(); // "Nicholas";
instance1.sayAge(); // 29
let instance2 = new SubType("Greg", 27);
console.log(instance2.colors); // "red,blue,green"
instance2.sayName(); // "Greg";
instance2.sayAge(); // 27
```



组合继承弥补了原型链和盗用构造函数的不足，是JavaScript 中使用最多的继承模式。而且组合继
承也保留了instanceof 操作符和isPrototypeOf()方法识别合成对象的能力。







## 8.3.4 原型式继承



即使不自定义类型也可以通过原型实现对象之间的信息共享。

```js
function object(o) {
    function F() {}
    F.prototype = o;
    return new F();
}
```



**object()函数会创建一个临时构造函数，将传入的对象赋值给这个构造函数的原型**，然后返
回这个临时类型的一个实例。本质上，object()是对传入的对象执行了一次浅复制。



ECMAScript 5 通过增加Object.create()方法将原型式继承的概念规范化了。这个方法接收两个
参数：作为新对象原型的对象，以及给新对象定义额外属性的对象（第二个可选）。在只有一个参数时，
Object.create()与这里的object()方法效果相同：





```js

let person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = Object.create(person);
anotherPerson.name = "Greg";
anotherPerson.friends.push("Rob");
let yetAnotherPerson = Object.create(person);
yetAnotherPerson.name = "Linda";
yetAnotherPerson.friends.push("Barbie");
console.log(person.friends); // "Shelby,Court,Van,Rob,Barbie"
```



Object.create()的第二个参数与Object.defineProperties()的第二个参数一样：每个新增
属性都通过各自的描述符来描述。以这种方式添加的属性会遮蔽原型对象上的同名属性。比如：

```js
let person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = Object.create(person, {
    name: {
        value: "Greg"
    }
});
console.log(anotherPerson.name); // "Greg"
```



**原型式继承非常适合不需要单独创建构造函数，但仍然需要在对象间共享信息的场合**。



缺点：属性中包含的引用值始终会在相关对象间共享，跟使用原型模式是一样的。





## 8.3.5 寄生式继承

寄生式继承背后的思路类似于寄生构造函数和工厂模式：创建一个实现继承的函数，以某种
方式增强对象，然后返回这个对象

```js
function createAnother(original){
    let clone = object(original); // 通过调用函数创建一个新对象
    clone.sayHi = function() { // 以某种方式增强这个对象
        console.log("hi");
    };
    return clone; // 返回这个对象
}
```



在这段代码中，createAnother()函数接收一个参数，就是新对象的基准对象。这个对象original
会被传给object()函数，然后将返回的新对象赋值给clone。接着给clone 对象添加一个新方法
sayHi()。最后返回这个对象。可以像下面这样使用createAnother()函数：

```js
let person = {
    name: "Nicholas",
    friends: ["Shelby", "Court", "Van"]
};
let anotherPerson = createAnother(person);
anotherPerson.sayHi(); // "hi"
```



这个例子基于person 对象返回了一个新对象。新返回的anotherPerson 对象具有person 的所
有属性和方法，还有一个新方法叫sayHi()。寄生式继承同样适合主要关注对象，而不在乎类型和构造函数的场景。object()函数不是寄生式继承所必需的，任何返回新对象的函数都可以在这里使用。



缺点： 通过寄生式继承给对象添加函数会导致函数难以重用，与构造函数模式类似

## 8.3.6 寄生式组合继承



组合继承其实也存在效率问题：最主要的效率问题就是**父类构造函数始终会被调用两次**：一次在是
创建子类原型时调用，另一次是在子类构造函数中调用。本质上，子类原型最终是要包含超类对象的所
有实例属性，子类构造函数只要在执行时重写自己的原型就行了。再来看一看这个组合继承的例子：



```js
function SuperType(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function() {
    console.log(this.name);
};
function SubType(name, age){
    SuperType.call(this, name); // 第二次调用SuperType()
    this.age = age;
}
SubType.prototype = new SuperType(); // 第一次调用SuperType()
SubType.prototype.constructor = SubType;
SubType.prototype.sayAge = function() {
    console.log(this.age);
};
```



寄生式组合继承通过盗用构造函数继承属性，但使用混合式原型链继承方法。基本思路是不通过调
用父类构造函数给子类原型赋值，而是取得父类原型的一个副本。说到底就是使用寄生式继承来继承父
类原型，然后将返回的新对象赋值给子类原型:





```js
function inheritPrototype(subType, superType) {
    let prototype = object(superType.prototype); // 创建对象
    prototype.constructor = subType; // 增强对象
    subType.prototype = prototype; // 赋值对象
}
```





寄生式组合继承：

```js
function inheritPrototype(subType, superType) {
    let prototype = Object.create(superType.prototype); // 创建对象，将superType的原型赋值给它
    prototype.constructor = subType; // 增强对象
    subType.prototype = prototype; // 赋值对象
}

function SuperType(name) {
    this.name = name;
    this.colors = ["red", "blue", "green"];
}
SuperType.prototype.sayName = function () {
    console.log(this.name);
};

function SubType(name, age) {
    SuperType.call(this, name);
    this.age = age;
}
inheritPrototype(SubType, SuperType);
SubType.prototype.sayAge = function () {
    console.log(this.age);
};
```



只调用了一次SuperType 构造函数，避免了SubType.prototype 上不必要也用不到的属性，
因此可以说这个例子的效率更高。原型链仍然保持不变，因此instanceof 操作符和isPrototypeOf()方法正常有效

寄生式组合继承可以算是引用类型继承的最佳模式







```js
let p = new SubType("tom", 25);
while (p != null) {
    console.log(p);
    p = Object.getPrototypeOf(p);
}
```



- 为什么打印p的原型在控制台打印为SuperType的实例，p.__proto__应该指向的是一个使用Object.create()创建的对象，其原型是SuperType.prototype吗？



chrome控制台:

```js
SubType {name: 'tom', colors: Array(3), age: 25}
SuperType {sayAge: ƒ}
{sayName: ƒ}
{__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}
```





Edge:

```js
SubType {name: 'tom', colors: Array(3), age: 25}
SuperType {constructor: ƒ, sayAge: ƒ}
{sayName: ƒ}
{__defineGetter__: ƒ, __defineSetter__: ƒ, hasOwnProperty: ƒ, __lookupGetter__: ƒ, __lookupSetter__: ƒ, …}
```





firefox

```js
Object { name: "tom", colors: (3) […], age: 25 }
Object { constructor: SubType(name, age), sayAge: sayAge()}
Object { sayName: sayName(), … }
Object { … }
```







（chatgpt 4o）Chrome 控制台打印对象时，前面的字符不一定是当前对象的构造函数类型。控制台可能根据对象的原型链和上下文来格式化显示。

- **原型信息**：如果对象的原型指向某个构造函数的原型，控制台可能会显示那个构造函数的名称，而不是真正的实例类型。
- **优化显示**：这种显示方式主要是为了帮助开发者更快地理解对象的结构和来源，但并不总是准确反映当前对象的实际类型。

因此，看到的构造函数名并不总是意味着该对象是该构造函数的实例。这是浏览器开发者工具中常见的行为，理解这一点有助于更好地解读控制台输出。





