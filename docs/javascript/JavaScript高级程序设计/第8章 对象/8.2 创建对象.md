# 8.2.1 概述

ECMAScript 5.1 并没有正式支持面向对象的结构，比如类或继承

ECMAScript 6 开始正式支持类和继承。ES6 的类旨在完全涵盖之前规范设计的基于原型的继承模
式。ES6 的类都仅仅是封装了ES5构造函数加原型继承的语法糖而已。



虽然使用Object 构造函数或对象字面量可以方便地创建对象，但这些方式也有明显不足：创建具
有同样接口的多个对象需要重复编写很多代码。

# 8.2.2 工厂模式



```js
function createPerson(name, age, job) {
    let o = new Object();
    o.name = name;
    o.age = age;
    o.job = job;
    o.sayName = function() {
        console.log(this.name);
    };
    return o;
}
let person1 = createPerson("Nicholas", 29, "Software Engineer");
let person2 = createPerson("Greg", 27, "Doctor");
```

函数createPerson()接收3 个参数，根据这几个参数构建了一个包含Person 信息的对象。
可以用不同的参数多次调用这个函数，每次都会返回包含3 个属性和1 个方法的对象。这种工厂模式虽
然可**以解决创建多个类似对象的问题，但没有解决对象标识问题（即新创建的对象是什么类型）**。



# 8.2.3 构造函数模式



```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    };
}
let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```





在这个例子中，Person()构造函数代替了createPerson()工厂函数。实际上，Person()内部
的代码跟createPerson()基本是一样的，只是有如下区别。

- 没有显式地创建对象。
- 属性和方法直接赋值给了this。
- 没有return。



按照惯例，构造函数名称的首字母都是要大写的，非构造函数则以小写字母开头。有助于在ECMAScript 中区分构
造函数和普通函数。毕竟ECMAScript 的构造函数就是能创建对象的函数。





要创建Person 的实例，应使用new 操作符。以这种方式调用构造函数会执行如下操作:

(1).在内存中创建一个新对象。

(2) 这个新对象内部的[[Prototype]]特性被赋值为构造函数的prototype 属性。

(3) this 指向新对象。

(4) 执行构造函数内部的代码（给新对象添加属性）。

(5) 如果构造函数返回非空对象，则返回该对象；否则，返回刚创建的新对象。





构造函数不一定要写成函数声明的形式。赋值给变量的函数表达式也可以表示构造函数：

```js
let Person = function(name, age, job) {
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = function() {
        console.log(this.name);
    };
}
let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true
```





在实例化时，如果不想传参数，那么构造函数后面的括号可加可不加。只要有new 操作符，就可以
调用相应的构造函数：

```js
function Person() {
this.name = "Jake";
this.sayName = function() {
console.log(this.name);
};
}
let person1 = new Person();
let person2 = new Person;

person1.sayName(); // Jake
person2.sayName(); // Jake
console.log(person1 instanceof Object); // true
console.log(person1 instanceof Person); // true
console.log(person2 instanceof Object); // true
console.log(person2 instanceof Person); // true
```



### 1.构造函数也是函数

构造函数与普通函数唯一的区别就是调用方式不同。除此之外，构造函数也是函数。并没有把某个
函数定义为构造函数的特殊语法。**任何函数只要使用new 操作符调用就是构造函数，而不使用new 操
作符调用的函数就是普通函数**。



```js
// 作为构造函数
let person = new Person("Nicholas", 29, "Software Engineer");
person.sayName(); // "Nicholas"
// 作为函数调用
Person("Greg", 27, "Doctor"); // 添加到window 对象
window.sayName(); // "Greg"
// 在另一个对象的作用域中调用
let o = new Object();
Person.call(o, "Kristen", 25, "Nurse");
o.sayName(); // "Kristen"
```





### 2.构造函数的问题

构造函数的主要问题在于其**定义的方法会在每个实例上都创建一遍**。

person1 和person2 都有名为sayName()的方法，但这两个方法不是同一个Function 实例。我们知道，ECMAScript 中的函数是对象，因此每次定义函数时，都会初始化一个对象。逻辑上讲，这个构造函数实际上是这样的：

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = new Function("console.log(this.name)"); // 逻辑等价
}
```



每个Person 实例都会有自己的Function 实例用于显示name 属性。当然了，以这种方式创建函数会带来不同的作用域链和标识符解析。但创建新Function实例的机制是一样的。因此不同实例上的函数虽然同名却不相等，如下所示：

```js
console.log(person1.sayName == person2.sayName); // false
```

因为都是做一样的事，所以没必要定义两个不同的Function 实例。况且，this 对象可以把函数
与对象的绑定推迟到运行时。要解决这个问题，可以把函数定义转移到构造函数外部：

```js
function Person(name, age, job){
    this.name = name;
    this.age = age;
    this.job = job;
    this.sayName = sayName;
}
function sayName() {
    console.log(this.name);
}
let person1 = new Person("Nicholas", 29, "Software Engineer");
let person2 = new Person("Greg", 27, "Doctor");
person1.sayName(); // Nicholas
person2.sayName(); // Greg
```



在这里，sayName()被定义在了构造函数外部。在构造函数内部，sayName 属性等于全局sayName()函数。因为这一次sayName 属性中包含的只是一个指向外部函数的指针，所以person1 和person2共享了定义在全局作用域上的sayName()函数。这样虽然解决了相同逻辑的函数重复定义的问题，但全局作用域也因此被搞乱了，因为那个函数实际上只能在一个对象上调用。如果这个对象需要多个方法，
那么就要在全局作用域中定义多个函数。这会导致自定义类型引用的代码不能很好地聚集一起。这个新问题可以通过原型模式来解决。





# 8.2.4 原型模式



每个函数都会创建一个prototype 属性，这个属性是一个对象，包含应该由特定引用类型的实例
共享的属性和方法。实际上，这个对象就是通过调用构造函数创建的对象的原型。**使用原型对象的好处
是，在它上面定义的属性和方法可以被对象实例共享**。原来在构造函数中直接赋给对象实例的值，可以
直接赋值给它们的原型，如下所示：



```JS
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person1 = new Person();
person1.sayName(); // "Nicholas"
let person2 = new Person();
person2.sayName(); // "Nicholas"
console.log(person1.sayName == person2.sayName); // true
```





使用函数表达式也行

```JS
let Person = function() {};
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person1 = new Person();
person1.sayName(); // "Nicholas"
let person2 = new Person();
person2.sayName(); // "Nicholas"
console.log(person1.sayName == person2.sayName); // true
```





### 1. 理解原型



无论何时，**只要创建一个函数，就会按照特定的规则为这个函数创建一个prototype 属性（指向
原型对象）**。默认情况下，所有原型对象自动获得一个名为constructor 的属性，指回与之关联的构
造函数。对前面的例子而言，Person.prototype.constructor 指向Person。然后，因构造函数而
异，可能会给原型对象添加其他属性和方法。
**在自定义构造函数时，原型对象默认只会获得constructor 属性，其他的所有方法都继承自
Object。每次调用构造函数创建一个新实例，这个实例的内部[[Prototype]]指针就会被赋值为构
造函数的原型对象。**脚本中没有访问这个[[Prototype]]特性的标准方式，但Firefox、Safari 和Chrome
会在每个对象上暴露__proto__属性，通过这个属性可以访问对象的原型。在其他实现中，这个特性
完全被隐藏了。关键在于理解这一点：实例与构造函数原型之间有直接的联系，但实例与构造函数之
间没有。



```js
/**
* 构造函数可以是函数表达式
* 也可以是函数声明，因此以下两种形式都可以：
* function Person() {}
* let Person = function() {}
*/
function Person() {}
/**
* 声明之后，构造函数就有了一个
* 与之关联的原型对象：
*/
console.log(typeof Person.prototype);
console.log(Person.prototype);
// {
// constructor: f Person(),
// __proto__: Object

// }
/**
* 如前所述，构造函数有一个prototype 属性
* 引用其原型对象，而这个原型对象也有一个
* constructor 属性，引用这个构造函数
* 换句话说，两者循环引用：
*/
console.log(Person.prototype.constructor === Person); // true
/**
* 正常的原型链都会终止于Object 的原型对象
* Object 原型的原型是null
*/
console.log(Person.prototype.__proto__ === Object.prototype); // true
console.log(Person.prototype.__proto__.constructor === Object); // true
console.log(Person.prototype.__proto__.__proto__ === null); // true
console.log(Person.prototype.__proto__);
// {
// constructor: f Object(),
// toString: ...
// hasOwnProperty: ...
// isPrototypeOf: ...
// ...
// }
let person1 = new Person(),
person2 = new Person();
/**
* 构造函数、原型对象和实例
* 是3 个完全不同的对象：
*/
console.log(person1 !== Person); // true
console.log(person1 !== Person.prototype); // true
console.log(Person.prototype !== Person); // true
/**
* 实例通过__proto__链接到原型对象，
* 它实际上指向隐藏特性[[Prototype]]
*
* 构造函数通过prototype 属性链接到原型对象
*
* 实例与构造函数没有直接联系，与原型对象有直接联系
*/
console.log(person1.__proto__ === Person.prototype); // true
conosle.log(person1.__proto__.constructor === Person); // true
/**
* 同一个构造函数创建的两个实例
* 共享同一个原型对象：
*/
console.log(person1.__proto__ === person2.__proto__); // true
/**
* instanceof 检查实例的原型链中
* 是否包含指定构造函数的原型：
*/
console.log(person1 instanceof Person); // true
console.log(person1 instanceof Object); // true
console.log(Person.prototype instanceof Object); // true
```



#### isPrototypeOf()

>  传入参数的[[Prototype]]指向调用它的对象时返回true

```js
console.log(Person.prototype.isPrototypeOf(person1)); // true
console.log(Person.prototype.isPrototypeOf(person2)); // true
```





#### Object.getPrototypeOf()

>  返回参数的内部特性[[Prototype]]的值



```js
console.log(Object.getPrototypeOf(person1) == Person.prototype); // true
console.log(Object.getPrototypeOf(person1).name); // "Nicholas"
```



#### Object.setPrototypeOf()

> 可以向实例的私有特性[[Prototype]]写入一个新值。这样就可以重写一个对象的原型继承关系

```js
let biped = {
    numLegs: 2
};
let person = {
    name: 'Matt'
};
Object.setPrototypeOf(person, biped);
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```



#### Object.create()

为避免使用Object.setPrototypeOf()可能造成的性能下降，可以通过Object.create()来创
建一个新对象，同时为其指定原型：



```js

let biped = {
numLegs: 2
};
let person = Object.create(biped);
person.name = 'Matt';
console.log(person.name); // Matt
console.log(person.numLegs); // 2
console.log(Object.getPrototypeOf(person) === biped); // true
```







### 2. 原型层级



在通过对象访问属性时，会按照这个属性的名称开始搜索。搜索开始于对象实例本身。如果在这个
实例上发现了给定的名称，则返回该名称对应的值。如果没有找到这个属性，则搜索会沿着指针进入原
型对象，然后在原型对象上找到属性后，再返回对应的值。



虽然可以通过实例读取原型对象上的值，但不可能通过实例重写这些值。如果在实例上添加了一个
与原型对象中同名的属性，那就会在实例上创建这个属性，这个属性会遮住原型对象上的属性



```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
person1.name = "Greg";
console.log(person1.name); // "Greg"，来自实例
console.log(person2.name); // "Nicholas"，来自原型
```



只要给对象实例添加一个属性，这个属性就会遮蔽（shadow）原型对象上的同名属性，也就是虽然
不会修改它，但会屏蔽对它的访问。即使在实例上把这个属性设置为null，也不会恢复它和原型的联
系。不过，使用delete 操作符可以完全删除实例上的这个属性，从而让标识符解析过程能够继续搜索
原型对象。





```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
person1.name = "Greg";
console.log(person1.name); // "Greg"，来自实例
console.log(person2.name); // "Nicholas"，来自原型
delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型
```



#### hasOwnProperty()

hasOwnProperty()方法用于确定某个属性是在实例上。这个方法是继承自Object的，会在属性存在于调用它的对象实例上时返回true，





```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty("name")); // false
person1.name = "Greg";
console.log(person1.name); // "Greg"，来自实例
console.log(person1.hasOwnProperty("name")); // true
console.log(person2.name); // "Nicholas"，来自原型
console.log(person2.hasOwnProperty("name")); // false
delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型
console.log(person1.hasOwnProperty("name")); // false
```





### 3.原型和in 操作符



**in 操作符会在可以通过对象访问指定属性时返回true，无论该属性是在实例上还是在原型上**



```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person1 = new Person();
let person2 = new Person();
console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true
person1.name = "Greg";
console.log(person1.name); // "Greg"，来自实例
console.log(person1.hasOwnProperty("name")); // true
console.log("name" in person1); // true
console.log(person2.name); // "Nicholas"，来自原型
console.log(person2.hasOwnProperty("name")); // false
console.log("name" in person2); // true
delete person1.name;
console.log(person1.name); // "Nicholas"，来自原型
console.log(person1.hasOwnProperty("name")); // false
console.log("name" in person1); // true
```





如果要确定某个属性是否存在于原型上

```js
function hasPrototypeProperty(object, name){
    return !object.hasOwnProperty(name) && (name in object);
}
```





```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function() {
    console.log(this.name);
};
let person = new Person();
console.log(hasPrototypeProperty(person, "name")); // true
person.name = "Greg";
console.log(hasPrototypeProperty(person, "name")); // false
```









在for-in 循环中使用in 操作符时，可以通过对象访问且可以被枚举的属性都会返回，包括实例属性和原型属性。

遮蔽原型中不可枚举（[[Enumerable]]特性被设置为false）属性的实例属性也会在for-in 循环中返回，因为默认情况下开发者定义的属性都是可枚举的。

要获得对象上**所有可枚举的实例属性**，可以使用Object.keys()方法。

这个方法接收一个对象作为参数，返回包含该对象所有可枚举属性名称的字符串数组:

```js
function Person() {}
Person.prototype.name = "Nicholas";
Person.prototype.age = 29;
Person.prototype.job = "Software Engineer";
Person.prototype.sayName = function () {
    console.log(this.name);
};
Object.defineProperty(Person.prototype, "age", {
    enumerable: false,
});
// Object.keys获得对象上所有可枚举的实例属性
let keys = Object.keys(Person.prototype);
console.log(keys); // "name,job,sayName"
let p1 = new Person();
p1.name = "Rob";
p1.age = 31;
let p1keys = Object.keys(p1);
console.log(p1keys); // "[name,age]"
```





如果想列出所有实例属性，**无论是否可以枚举**，都可以使用Object.getOwnPropertyNames()

```js
let keys = Object.getOwnPropertyNames(Person.prototype);
console.log(keys); // "[constructor,name,age,job,sayName]"
```



Object.keys()和Object.getOwnPropertyNames()在适当的时候都可用来代替for-in 循环。







Object.getOwnPropertySymbols()方法与Object.getOwnPropertyNames()类似，返回实例的所有符号属性



```js
let k1 = Symbol('k1'),
    k2 = Symbol('k2');
let o = {
    [k1]: 'k1',
    [k2]: 'k2'
};
console.log(Object.getOwnPropertySymbols(o));
// [Symbol(k1), Symbol(k2)]
```



### 4. 属性枚举顺序



for-in 循环、Object.keys()、Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()以及Object.assign()在属性枚举顺序方面有很大区别。for-in 循环和Object.keys()
的枚举顺序是不确定的，取决于JavaScript 引擎，可能因浏览器而异







Object.getOwnPropertyNames()、Object.getOwnPropertySymbols()和Object.assign()
的枚举顺序是确定性的。先以升序枚举数值键，然后以插入顺序枚举字符串和符号键



```js
let k1 = Symbol('k1'),
    k2 = Symbol('k2');
let o = {
    1: 1,
    first: 'first',
    [k1]: 'sym2',
    second: 'second',
    0: 0
};
o[k2] = 'sym2';
o[3] = 3;
o.third = 'third';
o[2] = 2;
console.log(Object.getOwnPropertyNames(o));
// ["0", "1", "2", "3", "first", "second", "third"]
console.log(Object.getOwnPropertySymbols(o));
// [Symbol(k1), Symbol(k2)]
```







# 8.2.5 对象迭代



ECMAScript 2017 新增了两个静态方法，用于将对象内容转换为序列化的——更重要的是可迭代的——格式。这两个静态方法
Object.values()和Object.entries()接收一个对象，返回它们内容的数组。

Object.values()返回对象值的数组，Object.entries()返回键/值对的数组。



```js
const o = {
    foo: 'bar',
    baz: 1,
    qux: {}
};
console.log(Object.values(o));
// ["bar", 1, {}]
console.log(Object.entries((o)));
// [["foo", "bar"], ["baz", 1], ["qux", {}]]
```

非字符串属性会被转换为字符串输出。另外，这两个方法执行对象的浅复制：

```js
const o = {
    qux: {}
};
console.log(Object.values(o)[0] === o.qux);
// true
console.log(Object.entries(o)[0][1] === o.qux);
```









符号属性会被忽略：



```js
const sym = Symbol();
const o = {
    [sym]: 'foo'
};
console.log(Object.values(o));
// []
console.log(Object.entries((o)));
// []
```





### 1. 其他原型语法



每次定义一个属性或方法都会把Person.prototype 重
写一遍。为了减少代码冗余，更好地封装原型功能，直接通过一个包含所有属性和方法的对象字面量来重写原型成为了一种常见的做法

```js
function Person() {}
Person.prototype = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    }
};
```



上面的写法完全重写了默认的prototype 对象，因此其constructor 属性也指向了完全不同
的新对象（Object 构造函数），不再指向原来的构造函数。虽然instanceof 操作符还能可靠地返回
值，但我们不能再依靠constructor 属性来识别类型了



```js
let friend = new Person();
console.log(friend instanceof Object); // true
console.log(friend instanceof Person); // true
console.log(friend.constructor == Person); // false
console.log(friend.constructor == Object); // true
```





在重写原型对象时专门设置一
下constructor 属性

```js
function Person() {
}
Person.prototype = {
    constructor: Person,
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    }
};
```



，以这种方式恢复constructor 属性会创建一个[[Enumerable]]为true 的属性。而
原生constructor 属性默认是不可枚举的



那么改为使用Object.defineProperty()方法来定义constructor 属性



```js
function Person() {}
Person.prototype = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    }
};
// 恢复constructor 属性
Object.defineProperty(Person.prototype, "constructor", {
    enumerable: false,
    value: Person
});
```







### 2. 原型的动态性

因为从原型上搜索值的过程是动态的，所以即使实例在修改原型之前已经存在，任何时候对原型对
象所做的修改也会在实例上反映出来。



```js
let friend = new Person();
Person.prototype.sayHi = function() {
    console.log("hi");
};
friend.sayHi(); // "hi"，没问题！
```



在调用friend.sayHi()时，首先会从这个实例中搜索名为sayHi 的属性。在没有找到的情况下，运行时会继续搜索原型对象。因为实例和原型之间的链接就是简单的指针，而不是保存的副本，所以会在原型上找到sayHi 属性并返回这个属
性保存的函数。

虽然随时能给原型添加属性和方法，并能够立即反映在所有对象实例上，但这跟重写整个原型是两
回事。

实例的[[Prototype]]指针是在调用构造函数时自动赋值的，这个指针即使把原型修改为不同的对象也不会变。重写整个原型会切断最初原型与构造函数的联系，但实例引用的仍然是最初的原型。
记住，**实例只有指向原型的指针，没有指向构造函数的指针**。



```js
function Person() {}
let friend = new Person();
Person.prototype = {
    constructor: Person,
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    }
};
friend.sayName(); // 错误
```



**重写构造函数上的原型之后再创建的实例才会引用新的原型。而在此之前创建的实例仍然会引用最初的原型。**



### 3. 原生对象原型

原型模式之所以重要，不仅体现在自定义类型上，而且还因为它也是实现所有原生引用类型的模式。
**所有原生引用类型的构造函数（包括Object、Array、String 等）都在原型上定义了实例方法**。比如，
数组实例的sort()方法就是Array.prototype 上定义的，而字符串包装对象的substring()方法也
是在String.prototype 上定义的，如下所示：

```js
console.log(typeof Array.prototype.sort); // "function"
console.log(typeof String.prototype.substring); // "function"
```



通过原生对象的原型可以取得所有默认方法的引用，也可以给原生类型的实例定义新的方法。**可以
像修改自定义对象原型一样修改原生对象原型，因此随时可以添加方法**。比如，下面的代码就给String
原始值包装类型的实例添加了一个startsWith()方法：



```js
String.prototype.startsWith = function (text) {
    return this.indexOf(text) === 0;
};
let msg = "Hello world!";
console.log(msg.startsWith("Hello")); // true
```





如果给定字符串的开头出现了调用startsWith()方法的文本，那么该方法会返回true。因为这个方法是被定义在String.prototype 上，所以当前环境下所有的字符串都可以使用这个方法。msg是个字符串，在读取它的属性时，后台会自动创建String 的包装实例，从而找到并调用startsWith()
方法。



### 4. 原型的问题

原型模式弱化了向构造函数传递初始化参数的能力，会导致所有实例默认都取得相同的属性值。虽然这会带来不便，但还不是原型的最大问题。原型的最主要问题源自它的共享特性。
原型上的所有属性是在实例间共享的，这对函数来说比较合适。另外包含原始值的属性也还好，可以通过在实例上添加同名属性来简单地遮蔽原型上的属性。真正的问题来自包含引用值的属性。来看下面的例子：

```js
function Person() {}
Person.prototype = {
    constructor: Person,
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    friends: ["Shelby", "Court"],

    sayName() {
        console.log(this.name);
    }
};
let person1 = new Person();
let person2 = new Person();
person1.friends.push("Van");
console.log(person1.friends); // "Shelby,Court,Van"
console.log(person2.friends); // "Shelby,Court,Van"
console.log(person1.friends === person2.friends); // true
```





一般来说，不同的实例应该有属于自己的属性副本。这就是实际开发中通常不单独使用原型模式的原因。