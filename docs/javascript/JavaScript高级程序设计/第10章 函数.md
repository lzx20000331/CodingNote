

函数实际上是对象。每个函数都是Function类型的实例，而Function 也有属性和方法，跟其他引用类型一样。

因为函数是对象，所以函数名就是指向函数对象的指针，而且不一定与函数本身紧密绑定



函数通常以函数声明的方式定义，比如：

```js
function sum (num1, num2) {
    return num1 + num2;
}
```



另一种定义函数的语法是函数表达式。函数表达式与函数声明几乎是等价的：

```js

let sum = function(num1, num2) {
    return num1 + num2;
};
```



还有一种定义函数的方式与函数表达式很像，叫作“箭头函数”（arrow function），如下所示：

```js
let sum = (num1, num2) => {
    return num1 + num2;
}
```



最后一种定义函数的方式是使用Function 构造函数。这个构造函数接收任意多个字符串参数，最
后一个参数始终会被当成函数体，而之前的参数都是新函数的参数。来看下面的例子：

```js
let sum = new Function("num1", "num2", "return num1 + num2"); // 不推荐
```

这段代码会被解释两次：第一次是将它当作常规ECMAScript 代码，第二次是解释传给构造函数的字符串。会影响性能。





# 10.1 箭头函数

ECMAScript 6 新增了使用胖箭头（=>）语法定义函数表达式的能力。任何可以使用函数表达式的地方，都
可以使用箭头函数：



```js
let arrowSum = (a, b) => {
    return a + b;
};
let functionExpressionSum = function(a, b) {
    return a + b;
};
console.log(arrowSum(5, 8)); // 13
console.log(functionExpressionSum(5, 8)); // 13
```


箭头函数简洁的语法非常适合嵌入函数的场景：

```js
let ints = [1, 2, 3];
console.log(ints.map(function(i) { return i + 1; })); // [2, 3, 4]
console.log(ints.map((i) => { return i + 1 })); // [2, 3, 4]
```



如果**只有一个参数，那也可以不用括号**。只有**没有参数，或者多个参数的情况下，才需要使用括号**：

```js
// 以下两种写法都有效
let double = (x) => { return 2 * x; };
let triple = x => { return 3 * x; };
// 没有参数需要括号
let getRandom = () => { return Math.random(); };
// 多个参数需要括号
let sum = (a, b) => { return a + b; };
// 无效的写法：
let multiply = a, b => { return a * b; };
```



如果不使用大括号，那么箭头后面就只能有一行代码，
比如一个**赋值操作**，或者一个**表达式**。而且，**省略大括号会隐式返回这行代码的值**：



```js
// 以下两种写法都有效，而且返回相应的值
let double = (x) => { return 2 * x; };
let triple = (x) => 3 * x;
// 可以赋值
let value = {};
let setName = (x) => x.name = "Matt";
setName(value);
console.log(value.name); // "Matt"
// 无效的写法：
let multiply = (a, b) => return a * b;
```



箭头函数虽然语法简洁，但也有很多场合不适用。**箭头函数不能使用arguments、super 和
new.target，也不能用作构造函数。此外，箭头函数也没有prototype 属性**。

# 10.2 函数名

函数名就是指向函数的指针，跟其他包含对象指针的变量具有相同的行为,这意味着一个函数可以有多个名称。

```js
function sum(num1, num2) {
    return num1 + num2;
}
console.log(sum(10, 10)); // 20
let anotherSum = sum;
console.log(anotherSum(10, 10)); // 20
sum = null;
console.log(anotherSum(10, 10)); // 20
```





# 10.3 理解参数

ECMAScript 函数既不关心传入的参数个数，也不关心这些参数的数据类型。定义函数时要接收两个参数，并不意味着调用时就传两个参数。你可以传一个、三个，甚至一个也不传，解释器都不会报错。

之所以会这样，主要是因为ECMAScript **函数的参数在内部表现为一个数组。函数被调用时总会接
收一个数组，但函数并不关心这个数组中包含什么**



**在使用function 关键字定义（非箭头）函数时，可以在函数内
部访问arguments 对象**，从中取得传进来的每个参数值,**arguments 对象是一个类数组对象**（但不是Array 的实例），因此可以使用中括号语法访问其中的元素（第一个参数是arguments[0]，第二个参数是arguments[1]）。而要确定传进来多少个参数，可以访问arguments.length 属性。

```js
function howManyArgs() {
console.log(arguments.length);
}
howManyArgs("string", 45); // 2
howManyArgs(); // 0
howManyArgs(12); // 1
```





还有一个必须理解的重要方面，那就是**arguments 对象可以跟命名参数一起使用**，比如：

```js
function doAdd(num1, num2) {
    if (arguments.length === 1) {
        console.log(num1 + 10);
    } else if (arguments.length === 2) {
        console.log(arguments[0] + num2);
    }
}
```





在这个doAdd()函数中，同时使用了两个命名参数和arguments 对象。命名参数num1 保存着与
arugments[0]一样的值，因此使用谁都无所谓。（同样，num2 也保存着跟arguments[1]一样的值。）
**arguments 对象的值始终会与对应的命名参数同步**。



```js
function doAdd(num1, num2) {
    arguments[1] = 10;
    console.log(arguments[0] + num2);
}
```







这个doAdd()函数把第二个参数的值重写为10。因为arguments 对象的值会自动同步到对应的命
名参数，所以修改arguments[1]也会修改num2 的值，因此两者的值都是10。但这**并不意味着它们都
访问同一个内存地址，它们在内存中还是分开的，只不过会保持同步而已**。另外还要记住一点：如果只
传了一个参数，然后把arguments[1]设置为某个值，那么这个值并不会反映到第二个命名参数。这是
因为**arguments 对象的长度是根据传入的参数个数，而非定义函数时给出的命名参数个数确定的**。
对于命名参数而言，如果调用函数时没有传这个参数，那么它的值就是undefined。这就类似于
定义了变量而没有初始化。比如，如果只给doAdd()传了一个参数，那么num2 的值就是undefined。



严格模式下，arguments 会有一些变化。首先，像前面那样给arguments[1]赋值不会再影响num2
的值。就算把arguments[1]设置为10，num2 的值仍然还是传入的值。其次，在函数中尝试重写
arguments 对象会导致语法错误。（代码也不会执行。）





箭头函数中的参数
如果函数是使用箭头语法定义的，那么传给函数的参数将不能使用arguments 关键字访问，而只
能通过定义的命名参数访问。

```js
function foo() {
    console.log(arguments[0]);
}
foo(5); // 5
let bar = () => {
    console.log(arguments[0]);
};
bar(5); // ReferenceError: arguments is not defined
```







虽然箭头函数中没有arguments 对象，但可以在包装函数中把它提供给箭头函数：

```js
function foo() {
    let bar = () => {
        console.log(arguments[0]); // 5
    };
    bar();
}
foo(5);
```





# 10.4 没有重载

ECMAScript 函数不能像传统编程那样重载。ECMAScript 函数没有签名，因为参数是由包含零个或多个值的数组表示的。



**没有函数签名，自然也就没有重载**。如果在ECMAScript 中定义了两个同名函数，则后定义的会覆盖先定义的。



定义了两个同名函数，则后定义的会覆盖先定义的。来看下面的例子：

```js

function addSomeNumber(num) {
return num + 100;
}
function addSomeNumber(num) {
return num + 200;
}
let result = addSomeNumber(100); // 30
```



```js
let addSomeNumber = function(num) {
return num + 100;
};
addSomeNumber = function(num) {
return num + 200;
};
```





# 10.5 默认参数值

在ECMAScript5.1 及以前，实现默认参数的一种常用方式就是检测某个参数是否等于undefined





ECMAScript 6 支持显式定义默认参数

```js
function makeKing(name = 'Henry') {
    return `King ${name} VIII`;
}
console.log(makeKing('Louis')); // 'King Louis VIII'
console.log(makeKing()); // 'King Henry VIII'
```





默认参数作用域与暂时性死区





# *10.6 参数扩展与收集

## 扩展参数

在给函数传参时，有时候可能不需要传一个数组，而是要分别传入数组的元素。



```js
let values = [1, 2, 3, 4];
function getSum() {
    let sum = 0;
    for (let i = 0; i < arguments.length; ++i) {
        sum += arguments[i];
    }
    return sum;
}
```



这个函数希望将所有加数逐个传进来，然后通过迭代arguments 对象来实现累加。如果不使用扩
展操作符，想把定义在这个函数这面的数组拆分，那么就得求助于apply()方法：

```js
console.log(getSum.apply(null, values)); // 10
```




但在ECMAScript 6 中，可以通过扩展操作符极为简洁地实现这种操作。

对可迭代对象应用扩展操作符，并将其作为一个参数传入，可以将可迭代对象拆分，并将迭代返回的每个值单独传入。
比如，使用扩展操作符可以将前面例子中的数组像这样直接传给函数：

```js
console.log(getSum(...values)); // 10
```





因为数组的长度已知，所以在使用扩展操作符传参的时候，并不妨碍在其前面或后面再传其他的值，
包括使用扩展操作符传其他参数：

```js
console.log(getSum(-1, ...values)); // 9
console.log(getSum(...values, 5)); // 15
console.log(getSum(-1, ...values, 5)); // 14
console.log(getSum(...values, ...[5,6,7])); // 28
```





对函数中的arguments 对象而言，它并不知道扩展操作符的存在，而是按照调用函数时传入的参
数接收每一个值：

```js

let values = [1,2,3,4]
function countArguments() {
    console.log(arguments.length);
}
countArguments(-1, ...values); // 5
countArguments(...values, 5); // 5
countArguments(-1, ...values, 5); // 6
countArguments(...values, ...[5,6,7]); // 7
```





在普通函数和箭头函数中，也可以将扩展操作符用于命名参数，当然同时也可以使用默认参数：

```js
function getProduct(a, b, c = 1) {
    return a * b * c;
}
let getSum = (a, b, c = 0) => {
    return a + b + c;
}
console.log(getProduct(...[1,2])); // 2
console.log(getProduct(...[1,2,3])); // 6
console.log(getProduct(...[1,2,3,4])); // 6
console.log(getSum(...[0,1])); // 1
console.log(getSum(...[0,1,2])); // 3
console.log(getSum(...[0,1,2,3])); // 3
```





## 收集参数

在构思函数定义时，可以使用扩展操作符把不同长度的独立参数组合为一个数组。这有点类似
arguments 对象的构造机制，只不过收集参数的结果会得到一个Array 实例。

```js
function getSum(...values) {
// 顺序累加values 中的所有值
// 初始值的总和为0
return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```



收集参数的前面如果还有命名参数，则只会收集其余的参数；如果没有则会得到空数组。因为**收集
参数的结果可变，所以只能把它作为最后一个参数**：

```js
// 不可以
function getProduct(...values, lastValue) {}
// 可以
function ignoreFirst(firstValue, ...values) {
console.log(values);
}
ignoreFirst(); // []
ignoreFirst(1); // []
ignoreFirst(1,2); // [2]
ignoreFirst(1,2,3);
```







箭头函数虽然不支持arguments 对象，但支持收集参数的定义方式，因此也可以实现与使用
arguments 一样的逻辑：

```js
let getSum = (...values) => {
    return values.reduce((x, y) => x + y, 0);
}
console.log(getSum(1,2,3)); // 6
```



另外，使用收集参数并不影响arguments 对象，它仍然反映调用时传给函数的参数：

```js

function getSum(...values) {
console.log(arguments.length); // 3
console.log(arguments); // [1, 2, 3]
console.log(values); // [1, 2, 3]
}
console.log(getSum(1,2,3));

```



# 10.7 函数声明与函数表达式 



JavaScript 引擎在任何代码执行之前，会先读取函数声明，并在执行上下文中生成函数定义。而函数表达式必须等到代码执行到它那一行，才会在执行上下文中生成函数定义。



函数声明会在任何代码执行之前先被读取并添加到执行上下文。这个过程叫作**函数声明提升**

```js
// 没问题
console.log(sum(10, 10));
function sum(num1, num2) {
    return num1 + num2;
}
```





```js
// 会出错
console.log(sum(10, 10));
let sum = function(num1, num2) {
    return num1 + num2;
};

```



```js
// 会出错
console.log(sum(10, 10));
var sum = function(num1, num2) {
return num1 + num2;
};
```



除了函数什么时候真正有定义这个区别之外，这两种语法是等价的。







# *10.8 函数作为值



因为函数名在ECMAScript 中就是变量，所以函数可以用在任何可以使用变量的地方。这意味着不
仅可以把函数作为参数传给另一个函数，而且还可以在一个函数中返回另一个函数

```js
function callSomeFunction(someFunction, someArgument) {
    return someFunction(someArgument);
}
```





这个函数接收两个参数。第一个参数应该是一个函数，第二个参数应该是要传给这个函数的值。任
何函数都可以像下面这样作为参数传递：

```js
function add10(num) {
    return num + 10;
}
let result1 = callSomeFunction(add10, 10);
console.log(result1); // 20
function getGreeting(name) {
    return "Hello, " + name;
}
let result2 = callSomeFunction(getGreeting, "Nicholas");
console.log(result2); // "Hello, Nicholas"
```





从一个函数中返回另一个函数也是可以的，而且非常有用。例如，假设有一个包含对象的数组，而
我们想按照任意对象属性对数组进行排序。为此，可以定义一个sort()方法需要的比较函数，它接收
两个参数，即要比较的值。但这个比较函数还需要想办法确定根据哪个属性来排序。这个问题可以通过
定义一个根据属性名来创建比较函数的函数来解决。比如：

```js
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        let value1 = object1[propertyName];
        let value2 = object2[propertyName];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
let data = [
    {name: "Zachary", age: 28},
    {name: "Nicholas", age: 29}
];
data.sort(createComparisonFunction("name"));
console.log(data[0].name); // Nicholas

data.sort(createComparisonFunction("age"));
console.log(data[0].name); // Zachary
```





# *10.9 函数内部



## arguments

arguments对象是一个**类数组对象**，包含调用函数时传入的所有参数，只有以function 关键字定义函数（相对于使用箭头语法创建函数）时才会有

arguments 对象其实还有一个**callee 属性**，是一个**指向arguments对象所在函数的
指针**。来看下面这个经典的阶乘函数：

```js
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
```





阶乘函数一般定义成递归调用的.只要给函数一个名称，而且这个名称不
会变，这样定义就没有问题。但是，这个函数要正确执行就必须保证函数名是factorial，从而导致
了紧密耦合。使用arguments.callee 就可以让函数逻辑与函数名解耦：

```js
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
```



这个重写之后的factorial()函数已经用arguments.callee 代替了之前硬编码的factorial。
这意味着无论函数叫什么名称，都可以引用正确的函数。考虑下面的情况：

```js
let trueFactorial = factorial;
factorial = function() {
    return 0;
};
console.log(trueFactorial(5)); // 120
console.log(factorial(5)); // 0
```



这里，trueFactorial 变量被赋值为factorial，实际上把同一个函数的指针又保存到了另一个
位置。然后，factorial 函数又被重写为一个返回0 的函数。如果像factorial()最初的版本那样不
使用arguments.callee，那么像上面这样调用trueFactorial()就会返回0。不过，通过将函数与
名称解耦，trueFactorial()就可以正确计算阶乘，而factorial()则只能返回0。





## this

在标准函数中，this 引用的是把函数当成方法调用的上下文对象，这时候通常称其为this 值

```js
window.color = 'red';
let o = {
    color: 'blue'
};
function sayColor() {
    console.log(this.color);
}
sayColor(); // 'red'
o.sayColor = sayColor;
o.sayColor(); // 'blue'
```



在箭头函数中，this 引用的是定义箭头函数的上下文



```js
window.color = 'red';
let o = {
    color: 'blue'
};
let sayColor = () => console.log(this.color);
sayColor(); // 'red'
o.sayColor = sayColor;
o.sayColor(); // 'red'
```



在事件回调或定时回调中调用某个函数时，this 值指向的并非想要的对象。此时将
回调函数写成箭头函数就可以解决问题。这是因为箭头函数中的this 会保留定义该函数时的上下文：



```js
function King() {
    this.royaltyName = 'Henry';
    // this 引用King 的实例
    setTimeout(() => console.log(this.royaltyName), 1000);
}
function Queen() {
    this.royaltyName = 'Elizabeth';
    // this 引用window 对象
    setTimeout(function() { console.log(this.royaltyName); }, 1000);
}
new King(); // Henry
new Queen(); // undefined
```







## caller

ECMAScript 5 也会给函数对象上添加一个属性：caller。虽然ECMAScript 3 中并没有定义，但所
有浏览器除了早期版本的 Opera 都支持这个属性。这个属性**引用的是调用当前函数的函数，或者如果是
在全局作用域中调用的则为null**。



```js
function outer() {
    console.log(outer.caller);
    inner();
}
function inner() {
    console.log(inner.caller);
}
outer();
```



ourter()调用了inner()，inner.caller指向outer()。如果要降低耦合度，则可以通过arguments.callee.caller 来引用同样的值





如果要降低耦合度，则可以通过arguments.callee.caller 来引用同样的值：

```js
function outer() {
    inner();
}
function inner() {
    console.log(arguments.callee.caller);
}
outer();
```





在严格模式下访问它会报错，在非严格模式下则始终是undefined。

这是为了分清arguments.caller和函数的caller 而故意为之的。而作为对这门语言的安全防护，这些改动也让第三方代码无法检测同一上下文中运行的其他代码。
**严格模式下还有一个限制，就是不能给函数的caller 属性赋值，否则会导致错误**。



## new.target

ECMAScript 中的函数始终可以作为构造函数实例化一个新对象，也可以作为普通函数被调用。
ECMAScript 6 新增了检测函数是否使用new 关键字调用的new.target 属性。

- 如果函数是正常调用的，则new.target 的值是undefined；

- 如果是使用new 关键字调用的，则new.target的值指向被调用的构造函数。





```js
function King() {
    if (!new.target) {
        throw 'King must be instantiated using "new"'
    }
    console.log('King instantiated using "new"');
}
new King(); // King instantiated using "new"
King(); // Error: King must be instantiated using "new"
```





# 10.10 函数属性方法

ECMAScript 中的**函数是对象，因此有属性和方法。每个函数都有两个属性：length
和prototype**。



**length 属性保存函数定义的命名参数的个数**：



```js
function sayName(name) {
    console.log(name);
}
function sum(num1, num2) {
    return num1 + num2;
}
function sayHi() {
    console.log("hi");
}
console.log(sayName.length); // 1
console.log(sum.length); // 2
console.log(sayHi.length); // 0
```



prototype 属性是不可枚举的，因此使用for-in 循环不会返回这个属性

| 方法    | 执行时机 | 参数形式       | 返回值     | 典型场景                |
| ------- | -------- | -------------- | ---------- | ----------------------- |
| `apply` | 立即执行 | 数组或类数组   | 无         | 动态参数、借用数组方法  |
| `call`  | 立即执行 | 逗号分隔列表   | 无         | 明确参数、借用对象方法  |
| `bind`  | 延迟执行 | 可预设部分参数 | 新绑定函数 | 固定 `this`、函数柯里化 |





# 10.11  函数表达式

函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量

```js
let functionName = function(arg0, arg1, arg2) {
    // 函数体
};
```





函数表达式看起来就像一个普通的变量定义和赋值，即创建一个函数再把它赋值给一个变量
functionName。这样创建的函数叫作**匿名函数，因为function 关键字后面没有
标识符**。未赋值给其他变量的匿名函数的name 属性是空字
符串。



函数表达式跟JavaScript 中的其他表达式一样，需要先赋值再使用。下面的例子会导致错误：

```js
sayHi(); // Error! function doesn't exist yet
let sayHi = function() {
    console.log("Hi!");
};
```





理解函数声明与函数表达式之间的区别，关键是理解提升



# 10.12 递归

递归函数通常的形式是一个函数通过名称调用自己





```js
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * factorial(num - 1);
    }
}
```

如果把这个函数赋值给其他变量，就会出问题：

```js
let anotherFactorial = factorial;
factorial = null;
console.log(anotherFactorial(4)); // 报错
```





这里把factorial()函数保存在了另一个变量anotherFactorial 中，然后将factorial 设置
为null，于是只保留了一个对原始函数的引用。而在调用anotherFactorial()时，要递归调用
factorial()，但因为它已经不是函数了，所以会出错。在写递归函数时使用arguments.callee 可
以避免这个问题。

arguments.callee 就是一个指向正在执行的函数的指针，因此可以在函数内部递归调用

```js
function factorial(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * arguments.callee(num - 1);
    }
}
```



不过，在**严格模式下运行的代码是不能访问arguments.callee 的，因为访问会出错**。此时，可
以使用命名函数表达式（named function expression）达到目的。比如：

```js
const factorial = (function f(num) {
    if (num <= 1) {
        return 1;
    } else {
        return num * f(num - 1);
    }
});
```





# 10.13 尾调用优化




ECMAScript 6 规范新增了一项内存管理优化机制，让JavaScript 引擎在满足条件时可以重用栈帧。
具体来说，这项优化非常适合“尾调用”，即外部函数的返回值是一个内部函数的返回值。比如：



```js
function outerFunction() {
return innerFunction(); // 尾调用
}
```



在ES6 优化之前，执行这个例子会在内存中发生如下操作。
(1) 执行到outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行outerFunction 函数体，到return 语句。计算返回值必须先计算innerFunction。
(3) 执行到innerFunction 函数体，第二个栈帧被推到栈上。
(4) 执行innerFunction 函数体，计算其返回值。
(5) 将返回值传回outerFunction，然后outerFunction 再返回值。
(6) 将栈帧弹出栈外。



在ES6 优化之后，执行这个例子会在内存中发生如下操作。
(1) 执行到outerFunction 函数体，第一个栈帧被推到栈上。
(2) 执行outerFunction 函数体，到达return 语句。为求值返回语句，必须先求值innerFunction。
(3) 引擎发现把第一个栈帧弹出栈外也没问题，因为innerFunction 的返回值也是outerFunction
的返回值。
(4) 弹出outerFunction 的栈帧。
(5) 执行到innerFunction 函数体，栈帧被推到栈上。
(6) 执行innerFunction 函数体，计算其返回值。
(7) 将innerFunction 的栈帧弹出栈外。

很明显，第一种情况下每多调用一次嵌套函数，就会多增加一个栈帧。而第二种情况下无论调用多
少次嵌套函数，都只有一个栈帧。这就是ES6 尾调用优化的关键：如果函数的逻辑允许基于尾调用将其
销毁，则引擎就会那么做。





## 尾递归调用优化的条件











## 尾递归调用优化的代码





可以通过把简单的递归函数转换为待优化的代码来加深对尾调用优化的理解。下面是一个通过递归
计算斐波纳契数列的函数：



```js
function fib(n) {
    if (n < 2) {
        return n;
    }
    return fib(n - 1) + fib(n - 2);
}
console.log(fib(0)); // 0
console.log(fib(1)); // 1
console.log(fib(2)); // 1
console.log(fib(3)); // 2
console.log(fib(4)); // 3
console.log(fib(5)); // 5
console.log(fib(6)); // 8
```





显然这个函数不符合尾调用优化的条件，因为返回语句中有一个相加的操作。结果，fib(n)的栈
帧数的内存复杂度是O(2n)。因此，即使这么一个简单的调用也可以给浏览器带来麻烦：
fib(1000);
当然，解决这个问题也有不同的策略，比如把递归改写成迭代循环形式。不过，也可以保持递归实
现，但将其重构为满足优化条件的形式。为此可以使用两个嵌套的函数，外部函数作为基础框架，内部
函数执行递归：



```js
"use strict";
// 基础框架
function fib(n) {
    return fibImpl(0, 1, n);
}
// 执行递归
function fibImpl(a, b, n) {
    if (n === 0) {
        return a;
    }
    return fibImpl(b, a + b, n - 1);
}

```





这样重构之后，就可以满足尾调用优化的所有条件，再调用fib(1000)就不会对浏览器造成威胁了。





# *10.14 闭包



闭包指的是**引用了另一个函数作用域中变量的函数**，通常是在嵌套函数中实现的。



```js
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        let value1 = object1[propertyName];
        let value2 = object2[propertyName];
        if (value1 < value2) {
            return -1;
        } else if (value1 > value2) {
            return 1;
        } else {
            return 0;
        }
    };
}
```

在调用一个函数时，会为这个函数调用创建一个执行上下文，并创建一个作用域链。然后用arguments
和其他命名参数来初始化这个函数的活动对象。外部函数的活动对象是内部函数作用域链上的第二个对
象。这个作用域链一直向外串起了所有包含函数的活动对象，直到全局执行上下文才终止。



```js
function compare(value1, value2) {
    if (value1 < value2) {
        return -1;
    } else if (value1 > value2) {
        return 1;
    } else {
        return 0;
    }
}
let result = compare(5, 10);
```

这里定义的compare()函数是在全局上下文中调用的。第一次调用compare()时，会为它创建一
个包含arguments、value1 和value2 的活动对象，这个对象是其作用域链上的第一个对象。而全局
上下文的变量对象则是compare()作用域链上的第二个对象，其中包含this、result 和compare。





函数执行时，每个执行上下文中都会有一个包含其中变量的对象。全局上下文中的叫变量对象，它
会在代码执行期间始终存在。而函数局部上下文中的叫活动对象，只在函数执行期间存在。在定义
compare()函数时，就会为它创建作用域链，预装载全局变量对象，并保存在内部的[[Scope]]中。在
调用这个函数时，会创建相应的执行上下文，然后通过复制函数的[[Scope]]来创建其作用域链。接着
会创建函数的活动对象（用作变量对象）并将其推入作用域链的前端。在这个例子中，这意味着compare()
函数执行上下文的作用域链中有两个变量对象：局部变量对象和全局变量对象。作用域链其实是一个包含指针的列表，每个指针分别指向一个变量对象，但物理上并不会包含相应的对象。





函数内部的代码在访问变量时，就会使用给定的名称从作用域链中查找变量。函数执行完毕后，局
部活动对象会被销毁，内存中就只剩下全局作用域。不过，闭包就不一样了。



在一个函数内部定义的函数会把其包含函数的活动对象添加到自己的作用域链中。因此，在
createComparisonFunction()函数中，匿名函数的作用域链中实际上包含createComparison-
Function()的活动对象

```js
function createComparisonFunction(propertyName) {
    return function(object1, object2) {
        let value1 = object1[propertyName];
        let value2 = object2[propertyName];
        if (value1 < value2) {
        	return -1;
        } else if (value1 > value2) {
        	return 1;
        } else {
        	return 0;
        }
    };
}
let compare = createComparisonFunction('name');
let result = compare({ name: 'Nicholas' }, { name: 'Matt' });
```

在createComparisonFunction()返回匿名函数后，它的作用域链被初始化为包含create-
ComparisonFunction()的活动对象和全局变量对象。这样，匿名函数就可以访问到createComparison-
Function()可以访问的所有变量。另一个有意思的副作用就是，createComparisonFunction()的
活动对象并不能在它执行完毕后销毁，因为匿名函数的作用域链中仍然有对它的引用。在create-
ComparisonFunction()执行完毕后，其执行上下文的作用域链会销毁，但它的活动对象仍然会保留
在内存中，直到匿名函数被销毁后才会被销毁：

```js
// 创建比较函数
let compareNames = createComparisonFunction('name');
// 调用函数
let result = compareNames({ name: 'Nicholas' }, { name: 'Matt' });
// 解除对函数的引用，这样就可以释放内存了
compareNames = null;
```

这里，创建的比较函数被保存在变量compareNames 中。把compareNames 设置为等于null 会
解除对函数的引用，从而让垃圾回收程序可以将内存释放掉。作用域链也会被销毁，其他作用域（除全
局作用域之外）也可以销毁。







# IIFE（立即调用函数表达式）



立即调用的匿名函数又被称作立即调用的函数表达式（IIFE，Immediately Invoked Function
Expression）。它类似于函数声明，但由于被包含在括号中，所以会被解释为函数表达式



```js
(function() {
// 块级作用域
})()
(function(){
}())
```









使用IIFE 可以模拟块级作用域，即在一个函数表达式内部声明变量，然后立即调用这个函数。这
样位于函数体作用域的变量就像是在块级作用域中一样。ECMAScript 5 尚未支持块级作用域，使用IIFE
模拟块级作用域是相当普遍的



```js
// IIFE
(function () {
    for (var i = 0; i < count; i++) {
        console.log(i);
    }
})();
console.log(i); // 抛出错误
```

在ECMAScript 5.1 及以前，为了防止变量定义外泄，IIFE 是个非常有效的方式。
这样也不会导致闭包相关的内存问题，因为不存在对这个匿名函数的引用。为此，只要函数执行完毕，
其作用域链就可以被销毁。





在ECMAScript 6 以后，IIFE 就没有那么必要了，因为块级作用域中的变量无须IIFE 就可以实现同
样的隔离。下面展示了两种不同的块级作用域形式：

```js
// 内嵌块级作用域
{
    let i;
    for (i = 0; i < count; i++) {
        console.log(i);
    }
}
console.log(i); // 抛出错误
// 循环的块级作用域
for (let i = 0; i < count; i++) {
    console.log(i);
}
console.log(i); // 抛出错误
```





说明IIFE 用途的一个实际的例子，就是可以用它锁定参数值。比如：
```js
let divs = document.querySelectorAll('div');
// 达不到目的！
for (var i = 0; i < divs.length; ++i) {
    divs[i].addEventListener('click', function() {
        console.log(i);
    });
}
```

使用IIFE

```js
let divs = document.querySelectorAll('div');
for (var i = 0; i < divs.length; ++i) {
    divs[i].addEventListener('click', (function(frozenCounter) {
        return function() {
            console.log(frozenCounter);
        };
    })(i));
}
```





使用ECMAScript 块级作用域变量，就不用这么大动干戈了：

```js
let divs = document.querySelectorAll('div');
for (let i = 0; i < divs.length; ++i) {
divs[i].addEventListener('click', function() {

console.log(i);
});
}
```







# 私有变量



严格来讲，JavaScript 没有私有成员的概念，所有对象属性都公有的。不过，倒是有私有变量的概
念。任何定义在函数或块中的变量，都可以认为是私有的，因为在这个函数或块的外部无法访问其中的
变量。私有变量包括函数参数、局部变量，以及函数内部定义的其他函数。

特权方法（privileged method）是能够访问函数私有变量（及私有函数）的公有方法。在对象上有
两种方式创建特权方法。第一种是在构造函数中实现:

```js
function MyObject() {
    // 私有变量和私有函数
    let privateVariable = 10;
    function privateFunction() {
        return false;
    }
    // 特权方法
    this.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
}
```

因为定义在构造函数中的特权方法其实是一个闭包，它具有访问构造函数中定义的所有变量和函数的能力

```js
function Person(name) {
    this.getName = function() {
        return name;
    };
    this.setName = function (value) {
        name = value;
    };
}
let person = new Person('Nicholas');
console.log(person.getName()); // 'Nicholas'
person.setName('Greg');
console.log(person.getName()); // 'Greg'
```





构造函数模式的缺点是每个实例都会重新创建一遍新方法。使用静态私有变量实现特权方法可以避免这个问题。



## 静态私有变量

 特权方法也可以通过使用私有作用域定义私有变量和函数来实现。这个模式如下所示：


```js
(function() {
    // 私有变量和私有函数
    let privateVariable = 10;
    function privateFunction() {
        return false;
    }
    // 构造函数
    MyObject = function() {};
    // 公有和特权方法
    MyObject.prototype.publicMethod = function() {
        privateVariable++;
        return privateFunction();
    };
})();
```

在这个模式中，匿名函数表达式创建了一个包含构造函数及其方法的私有作用域

这个模式与前一个模式的主要区别就是，私有变量和私有函数是由实例共享的。因为特权方法定义在原型上，所以同样是由实例共享的。特权方法作为一个闭包，始终引用着包含它的作用域





```js
(function() {
    let name = '';
    Person = function(value) {
        name = value;
    };
    Person.prototype.getName = function() {
        return name;
    };
    Person.prototype.setName = function(value) {
        name = value;
    };
})();
let person1 = new Person('Nicholas');
console.log(person1.getName()); // 'Nicholas'
person1.setName('Matt');
console.log(person1.getName()); // 'Matt'
let person2 = new Person('Michael');
console.log(person1.getName()); // 'Michael'
console.log(person2.getName()); // 'Michael'
```

这里的Person 构造函数可以访问私有变量name，跟getName()和setName()方法一样。使用这种模式，name 变成了静态变量，可供所有实例使用。这意味着在任何实例上调用setName()修改这个变量都会影响其他实例

创建静态私有变量可以利用原型更好地重用代码，只是每个实例没有了自己的私有变量。最终，到底是把私有变量放在实例中，还是作为静态私有变量，都需要根据自己的需求来确定。





## 模块模式
