## 











## Undefined

> Undefined 类型只有一个值undefined。

- 当使用var 或let 声明了变量但没有初始化时，就相当于给变量赋予了undefined 值：

```js
let message;
console.log(message == undefined); // true
```

等价于

```js
let message = undefined;
console.log(message == undefined); // true
```

变量message 显式地以undefined 来初始化。但这是不必要的，因为默认情况下，**任何未经初始化的变量都会取得undefined 值**



- 包含undefined 值的变量跟未定义变量是有区别的

```js
let message; // 这个变量被声明了，只是值为undefined
// 确保没有声明过这个变量
// let age
console.log(message); // "undefined"
console.log(age); // 报错
```

对未声明的变量，只能执行一个有用的操作，就是对它调用typeof。（对未声明的变量调用delete 也不会报错，但这个操作没什么用，实际上在严格模式下会抛出错误。）



```js
let message; // 这个变量被声明了，只是值为undefined
// 确保没有声明过这个变量
// let age
console.log(typeof message); // "undefined"
console.log(typeof age); // "undefined"
```



无论是声明还是未声明，typeof 返回的都是字符串"undefined"。逻辑上讲这是对的，因为虽然
严格来讲这两个变量存在根本性差异，但它们都无法执行实际操作。





- undefined 是一个假值



```js
let message; // 这个变量被声明了，只是值为undefined
// age 没有声明
if (message) {
// 这个块不会执行
}
if (!message) {
// 这个块会执行
}
if (age) {
// 这里会报错
}
```







## Null

> Null类型只有一个值null,表示一个空对象指针



```js
let car = null;
console.log(typeof car); // "object"
```





（==）比较null 和undefined 始终返回true。但要注意，这个操作符会为了比较而转换它的操作数







## Number

> Number 类型使用IEEE 754 格式表示整数和浮点值（在某些语言中也叫双精度值）。

不同的数值类型相应地也有不同的数值字面量格式。





|        | 前缀   |            |
| ------ | ------ | ---------- |
| 10进制 |        | 0,3,100    |
| 2进制  | 0b或0B | 0b11,0b11  |
| 8进制  | 0o或0O | 0o11,0O11  |
| 16进制 | 0x或0X | 0xff, 0XFF |



- 10进制字面量直接写成数字序列

```
0
3
10000000
```



- 2进制字面量以0b或0B开头

```
0b10101
0B10101
```



- 8进制字面量以0o或0O开头

```js
let a = 0O11 //9
let b = 0o11 //9
```



- 16进制字面量以0x或0X开头

```
0xff
0xBADCAFE
```





### 1.浮点值



对于非常大或非常小的数值，浮点值可以用科学记数法来表示: 即实数值后面可以跟字母e（或E ），跟一个可
边的加号或减号，再跟一个整数指数。这种记数表示的是实数值乘以10的指数次幂。

```js
3.14
2345.6789
.333333333333333333
6.02e23 // 6.02 * 10^(23)
1.4738223E-32 // 1.473822 X 10^(-32)
```





可以用下划线(_)将数值字面量分隔为容易看清的数字段：

```js
let billion = 1_000_000_000	// 以下划线作为千分位分隔符
let bytes = 0x89_AB_CD_EF	// 作为字节分隔符
let bits = 0b0001_1101_0111		// 作为半字节分隔符
let fraction = 0.123_456_789	//也可以用在小数部分
```



### 2.值的范围

由于内存的限制，ECMAScript 并不支持表示这个世界上的所有数值

ECMAScript 可以表示的最小数值保存在Number.MIN_VALUE 中；可以表示的最大数值保存在Number.MAX_VALUE 中



如果某个计算得到的数值结果超出了JavaScript 可以表示的范围，那么这个数值会被自动转换为一个特殊的Infinity（无
穷）值。任何无法表示的负数以-Infinity（负无穷大）表示，任何无法表示的正数以Infinity（正无穷大）表

- isFinite（）函数

如果计算返回正Infinity 或负Infinity，则该值将不能再进一步用于任何计算。这是因为
Infinity 没有可用于计算的数值表示形式。要确定一个值是不是有限大（即介于JavaScript 能表示的最小值和最大值之间），可以使用isFinite()函数，

```js
let result = Number.MAX_VALUE + Number.MAX_VALUE;
console.log(isFinite(result)); // false
```



### 3.NaN

有一个特殊的数值叫NaN，意思是“不是数值”（Not a Number），用于表示本来要返回数值的操作
失败了（而不是抛出错误)

用0 除任意数值在其他语言中通常都会导致错误，从而中止代码执行。但在ECMAScript 中，0、+0 或-0 相除会返回NaN：



```js
console.log(0/0); // NaN
console.log(-0/+0); // NaN
```

如果分子是非0 值，分母是有符号0 或无符号0，则会返回Infinity 或-Infinity：

```js
console.log(5/0); // Infinity
console.log(5/-0); // -Infinity
```





- NaN的特殊的属性：
  - 任何涉及NaN 的操作始终返回NaN，，任何涉及NaN 的操作始终返回NaN（如NaN/10）
  - NaN 不等于包括NaN 在内的任何值

```js
console.log(NaN == NaN); // false
```





- isNaN()函数

  该函数接收一个参数，可以是任意数据类型，然后判断这个参数是否“不是数值”。

  把一个值传给isNaN()后，该函数会尝试把它转换为数值。某些非数值的值可以直接转换成数值，

```js
console.log(isNaN(NaN)); // true
console.log(isNaN(10)); // false，10 是数值
console.log(isNaN("10")); // false，可以转换为数值10
console.log(isNaN("blue")); // true，不可以转换为数值
console.log(isNaN(true)); // false，可以转换为数值1
```











## String

> 表示零或多个16 位Unicode 字符序列。

字符串可以使用双引号（"）、单引号（'）或反引号（`）标示，

```js
let firstName = "John";
let lastName = 'Jacob';
let lastName = `Jingleheimerschmidt`
```



跟某些语言中使用不同的引号会改变对字符串的解释方式不同(如Java中单引号表示字符，双引号表示字符串)，ECMAScript 语法中表示字符串的引号没有区别。不过要注意的是，**以某种引号作为字符串开头，必须仍然以该种引号作为字符串结尾**。
比如，下面的写法会导致语法错误：

```js
let firstName = 'Nicholas"; //Uncaught SyntaxError: Invalid or unexpected token
```





### 1.字符字面量



| 字符  | 含义                                                         |
| ----- | ------------------------------------------------------------ |
| \n    | 换行                                                         |
| \t    | 制表                                                         |
| \b    | 退格                                                         |
| \r    | 回车                                                         |
| \f    | 换页                                                         |
| \\\   | 反斜杠                                                       |
| \'    | 单引号                                                       |
| \\"   | 双引号                                                       |
| \\`   | 反引号                                                       |
| \xnn  | 以十六进制编码nn 表示的字符（其中n 是十六进制数字0~F），例如\x41 等于"A"（4*16+1=65） |
| \unnn | 以十六进制编码nnnn 表示的Unicode 字符（其中n 是十六进制数字0~F），例如\u03a3 等于希腊字符"Σ" |



这些字符字面量可以出现在字符串中的任意位置，且可以作为单个字符被解释：

```js
let text = "This is the letter sigma: \u03a3.";
```



**字符串的长度可以通过其length 属性获取**：

```js
console.log(text.length); // 28
```

这个属性返回字符串中16 位字符的个数





### 2.字符串的特点

ECMAScript 中的**字符串是不可变的**（immutable），意思是一旦创建，它们的值就不能变了。要修改
某个变量中的字符串值，必须先销毁原始的字符串，然后将包含新值的另一个字符串保存到该变量



```js
let lang = "Java";
lang = lang + "Script";
```

整个过程首先会分配一个足够容纳10 个字符的空间，然后填充上"Java"和"Script"。最后销毁原始的字符串"Java"和字符串"Script"，因为这两个字符串都没有用了。所有处理都是在后台发生的，而这也是一些早期的浏览器（如Firefox 1.0 之前的版本和IE6.0）在拼接字符串时非常慢的原因





### 3.转换为字符串



有两种方式把一个值转换为字符串。



- toString方法

几乎所有值都有的toString()方法。toString()方法可见于数值、布尔值、对象和字符串值。（没错，字符串值也有toString()方法，该方法只是简单地返回自身的一个副本。）

**null 和undefined 值没有toString()方法。**



```js
let age = 11;
let ageAsString = age.toString(); // 字符串"11"
let found = true;
let foundAsString = found.toString(); // 字符串"true"
```





多数情况下，toString()不接收任何参数。不过，在对数值调用这个方法时，toString()可以接收一个底数参数，即以什么底数来输出数值的字符串表示。默认情况下，toString()返回数值的十
进制字符串表示。而通过传入参数，可以得到数值的二进制、八进制、十六进制，或者其他任何有效基
数的字符串表示



```js
let num = 10;
console.log(num.toString()); // "10"
console.log(num.toString(2)); // "1010"
console.log(num.toString(8)); // "12"
console.log(num.toString(10)); // "10"
console.log(num.toString(16)); // "a"
```





- String全局函数

函数遵循如下规则。

1.如果值有toSting()方法，则调用该方法(不传参数)并返回结果

2.如果值是null,返回 “null”

3.如果值是undefined,返回 “undefined”



```js
let value1 = 10;
let value2 = true;
let value3 = null;
let value4;
console.log(String(value1)); // "10"
console.log(String(value2)); // "true"
console.log(String(value3)); // "null"
console.log(String(value4)); // "undefined"
```





### 4.模板字符串

ES6新增了使用模板字面量定义字符串的能力。与使用单引号或双引号不同，

**模板字面量保留换行字符，可以跨行定义字符串**



```js
let myTemplateLiteral = `first line
						 second line`;
console.log(myTemplateLiteral.length); // 47
// 这个模板字面量以一个换行符开头
let secondTemplateLiteral = `first line
second line`;
console.log(secondTemplateLiteral[0] === '\n'); // true
// 这个模板字面量没有意料之外的字符
let thirdTemplateLiteral = `first line
second line`;
console.log(thirdTemplateLiteral);
// first line
// second line
```





### 5.字符串插值



模板字面量最常用的一个特性是支持字符串插值，也就是可以在一个连续定义中插入一个或多个
值。技术上讲，模板字面量不是字符串，而是一种特殊的JavaScript 句法表达式，只不过求值后得到的
是字符串。



字符串插值通过在 ${} 中使用一个JavaScript 表达式实现：

```js
let value = 5;
let exponent = 'second';
// 以前，字符串插值是这样实现的：
let interpolatedString = value + ' to the ' + exponent + ' power is ' + (value * value);
// 现在，可以用模板字面量这样实现：
let interpolatedTemplateLiteral =
`${ value } to the ${ exponent } power is ${ value * value }`;
console.log(interpolatedString); // 5 to the second power is 25
console.log(interpolatedTemplateLiteral); // 5 to the second power is 25
```



将表达式转换为字符串时会调用toString()或String()：

```js
let foo = { toString: () => 'World' };
console.log(`Hello, ${ foo }!`); // Hello, World!
let fun;
console.log(`Hello, ${ fun }!`); // Hello, undefined!
```



在插值表达式中可以调用函数和方法：
```js
function capitalize(word) {
    return `${ word[0].toUpperCase() }${ word.slice(1) }`;
}
console.log(`${ capitalize('hello') }, ${ capitalize('world') }!`); // Hello, World!
```



此外，模板也可以插入自己之前的值：

```js
let value = '';
function append() {
    value = `${value}abc`
    console.log(value);
}
append(); // abc
append(); // abcabc
append(); // abcabcabc
```



### 模板字面量标签函数



### 原始字符串



## Boolean

> Boolean（布尔值）类型有两个字面值：true 和false。



- 布尔值在JavaScript 常用于控制结构。

例如， JavaScript 中的if/else 语句在布尔值为true 时会执行一种操作，而在值为false 时会执行另一种操作。

```js
if (a === 4 ) {
    b = b + 1;
} else {
    a = a + 1;
}
```









- Boolean()转型函数



Boolean()转型函数可以在任意类型的数据上调用，而且始终返回一个布尔值

不同类型与布尔值之间的转换规则:

| 数据类型  |    转换为true 的值     | 转换为false 的值 |
| :-------: | :--------------------: | :--------------: |
|  String   |       非空字符串       |  ""（空字符串）  |
|  Number   | 非零数值（包括无穷值） |      0、NaN      |
|  Object   |        任意对象        |       null       |
| Undefined |     N/A（不存在）      |    undefined     |





**JavaScript 的任何值都可以转换为布尔值**，其中undefined,null, 0,-0,NaN, 空字符串 转换为布尔值false

所有其他值，包括所有对象（和数组）都转换为（可以被用作）布尔值true 















## Symbol

> ES6 新增的一种原始类型，用来创建唯一记号，进而用作非字符串形式的对象属性。



每个从 `Symbol()` 返回的 symbol 值都是唯一的。symbol 值是为了作为对象属性的标识符而诞生的。







### 1.基本用法



符号需要**使用Symbol()函数初始化**

```js
let sym = Symbol();
console.log(typeof sym); // symbol
```

调用Symbol()函数时，也可以传入一个字符串参数作为对符号的描述（description),将来可以通过这个字符串来调试代码。但是，这个**字符串参数与符号定义或标识完全无关**

```js
let genericSymbol = Symbol();
let otherGenericSymbol = Symbol();
let fooSymbol = Symbol('foo');
let otherFooSymbol = Symbol('foo');
console.log(genericSymbol == otherGenericSymbol); // false
console.log(fooSymbol == otherFooSymbol); // false
```



符号没有字面量语法，这也是它们发挥作用的关键。按照规范，你只要创建Symbol()实例并将其
用作对象的新属性，就可以保证它不会覆盖已有的对象属性，无论是符号属性还是字符串属性。

```js
let genericSymbol = Symbol();
console.log(genericSymbol); // Symbol()
let fooSymbol = Symbol('foo');
console.log(fooSymbol); // Symbol(foo);
```



**Symbol()函数不能与new 关键字一起作为构造函数使用**。这样做是为了避免创建符
号包装对象，像使用Boolean、String 或Number 那样，它们都支持构造函数且可用于初始化包含原
始值的包装对象：

```js
let myBoolean = new Boolean();
console.log(typeof myBoolean); // "object"
let myString = new String();
console.log(typeof myString); // "object"
let myNumber = new Number();
console.log(typeof myNumber); // "object"
let mySymbol = new Symbol(); // TypeError: Symbol is not a constructor
```




如果你确实想使用符号包装对象，可以借用Object()函数：

```js
let mySymbol = Symbol();
let myWrappedSymbol = Object(mySymbol);
console.log(typeof myWrappedSymbol); // "object"
```



### 2.使用全局符号注册表



- Symbol.for()方法

如果运行时的不同部分需要共享和重用符号实例，那么可以用一个字符串作为键，在全局符号注册
表中创建并重用符号。

```js
let fooGlobalSymbol = Symbol.for('foo');
console.log(typeof fooGlobalSymbol); // symbol
```

Symbol.for()对每个字符串键都执行幂等操作。第一次使用某个字符串调用时，它会检查全局运
行时注册表，发现不存在对应的符号，于是就会生成一个新符号实例并添加到注册表中。后续使用相同
字符串的调用同样会检查注册表，发现存在与该字符串对应的符号，然后就会返回该符号实例。

```js
let fooGlobalSymbol = Symbol.for('foo'); // 创建新符号
let otherFooGlobalSymbol = Symbol.for('foo'); // 重用已有符号
console.log(fooGlobalSymbol === otherFooGlobalSymbol); // true
```

即使采用相同的符号描述，在Symbol.for()定义的符号跟使用Symbol()定义的符号也并不等同：

```js
let localSymbol = Symbol('foo');
let globalSymbol = Symbol.for('foo');
console.log(localSymbol === globalSymbol); // false
```

全局注册表中的符号必须使用字符串键来创建，因此作为参数传给Symbol.for()的任何值都会被转换为字符串。此外，注册表中使用的键同时也会被用作符号描述。

```js
let emptyGlobalSymbol = Symbol.for();
console.log(emptyGlobalSymbol); // Symbol(undefined)
```

还可以使用Symbol.keyFor()来查询全局注册表，这个方法接收符号，返回该全局符号对应的字
符串键。如果查询的不是全局符号，则返回undefined。

```js
// 创建全局符号
let s = Symbol.for('foo');
console.log(Symbol.keyFor(s)); // foo
// 创建普通符号
let s2 = Symbol('bar');
console.log(Symbol.keyFor(s2)); // undefined
```

如果传给Symbol.keyFor()的不是符号，则该方法抛出TypeError：

```js
Symbol.keyFor(123); // TypeError: 123 is not a symbol
```







### 3.使用符号作为属性







### 4.常用内置符号









- 







## Object

> 对象其实就是一组数据和功能的集合。





每个Object 实例都有如下属性和方法。

- constructor：用于创建当前对象的函数。在前面的例子中，这个属性的值就是Object()
  函数。

- hasOwnProperty(propertyName)：用于判断当前对象实例（不是原型）上是否存在给定的属
  性。要检查的属性名必须是字符串（如o.hasOwnProperty("name")）或符号。

- isPrototypeOf(object)：用于判断当前对象是否为另一个对象object的原型。
- propertyIsEnumerable(propertyName)：用于判断给定的属性是否可以使用for-in 语句枚举。与hasOwnProperty()一样，属性名必须是字符串。

- toLocaleString()：返回对象的字符串表示，该字符串反映对象所在的本地化执行环境。

- toString()：返回对象的字符串表示。

- valueOf()：返回对象对应的字符串、数值或布尔值表示。通常与toString()的返回值相同。

## typeof判断数据类型

> **`typeof`** 运算符返回一个字符串，表示操作数的类型。

```js
console.log(typeof 42);
// Expected output: "number"

console.log(typeof 'blubber');
// Expected output: "string"

console.log(typeof true);
// Expected output: "boolean"

console.log(typeof undeclaredVariable);
// Expected output: "undefined"
```



|                                                              |                                                              |
| ------------------------------------------------------------ | ------------------------------------------------------------ |
| [Undefined](https://developer.mozilla.org/zh-CN/docs/Glossary/Undefined) | `"undefined"`                                                |
| [Null](https://developer.mozilla.org/zh-CN/docs/Glossary/Null) | `"object"`（[原因](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof#typeof_null)） |
| [Boolean](https://developer.mozilla.org/zh-CN/docs/Glossary/Boolean) | `"boolean"`                                                  |
| [Number](https://developer.mozilla.org/zh-CN/docs/Glossary/Number) | `"number"`                                                   |
| [BigInt](https://developer.mozilla.org/zh-CN/docs/Glossary/BigInt) | `"bigint"`                                                   |
| [String](https://developer.mozilla.org/zh-CN/docs/Glossary/String) | `"string"`                                                   |
| [Symbol](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol) | `"symbol"`                                                   |
| [Function](https://developer.mozilla.org/zh-CN/docs/Glossary/Function) | `"function"`                                                 |
| 其他任何对象                                                 | `"object"`                                                   |





### 类型转换

|      | Number | Boolean |
| ---- | ------ | ------- |
|      |        |         |
|      |        |         |
|      |        |         |
|      |        |         |
|      |        |         |
|      |        |         |
|      |        |         |
| {}   |        | true    |
| []   | 0      | true    |





