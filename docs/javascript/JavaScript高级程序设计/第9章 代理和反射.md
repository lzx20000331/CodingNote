# 代理基础

## 什么是代理

**代理是目标对象的抽象**。

ECMAScript 6 新增的代理和反射**为开发者提供了拦截并向基本操作嵌入额外行为的能力**。具体地
说，可以给目标对象定义一个关联的代理对象，而这个代理对象可以作为抽象的目标对象来使用。**在对
目标对象的各种操作影响目标对象之前，可以在代理对象中对这些操作加以控制**。



## 创建空代理

代理是使用Proxy 构造函数创建的，这个构造函数接收两个参数：目标对象和处理程序对象。缺
少其中任何一个参数都会抛出TypeError。

```js
let proxy = new Proxy(target, handler)
```

要创建空代理，可以传一个简单的对象字面量作为处理程序对象，从而让所有操作畅通无阻地抵达目标对象。

**在代理对象上执行的任何操作实际上都会应用到目标对象**

```js
const target = {
    id: 'target'
};
const handler = {};
const proxy = new Proxy(target, handler);
// id 属性会访问同一个值
console.log(target.id); // target
console.log(proxy.id); // target
// 给目标属性赋值会反映在两个对象上
// 因为两个对象访问的是同一个值
target.id = 'foo';
console.log(target.id); // foo
console.log(proxy.id); // foo
// 给代理属性赋值会反映在两个对象上
// 因为这个赋值会转移到目标对象
proxy.id = 'bar';
console.log(target.id); // bar
console.log(proxy.id); // bar
// hasOwnProperty()方法在两个地方
// 都会应用到目标对象
console.log(target.hasOwnProperty('id')); // true
console.log(proxy.hasOwnProperty('id')); // true
// Proxy.prototype 是undefined
// 因此不能使用instanceof 操作符
console.log(target instanceof Proxy); 
// TypeError: Function has non-object prototype 'undefined' in instanceof check
console.log(proxy instanceof Proxy); 
// TypeError: Function has non-object prototype 'undefined' in instanceof check
// 严格相等可以用来区分代理和目标
console.log(target === proxy); // false
```

## 定义捕获器

使用代理的主要目的是可以定义捕获器（trap）。捕获器就是在处理程序对象中定义的“基本操作的
拦截器”。每个处理程序对象可以包含零个或多个捕获器，每个捕获器都对应一种基本操作，可以直接
或间接在代理对象上调用。每次在代理对象上调用这些基本操作时，代理可以在这些操作传播到目标对
象之前先调用捕获器函数，从而拦截并修改相应的行为。



例如可以定义一个get()捕获器，在ECMAScript 操作以某种形式调用get()时触发。

```js
const target = {
    foo: 'bar'
};
const handler = {
    // 捕获器在处理程序对象中以方法名为键
    get() {
        return 'handler override';
    }
};
const proxy = new Proxy(target, handler);
```





这样，**当通过代理对象执行get()操作时，就会触发定义的get()捕获器**。当然，get()不是
ECMAScript 对象可以调用的方法。这个操作在JavaScript 代码中可以通过多种形式触发并被get()捕获
器拦截到。proxy[property]、proxy.property 或Object.create(proxy)[property]等操作都
会触发基本的get()操作以获取属性。因此所有这些操作只要发生在代理对象上，就会触发get()捕获
器。注意，**只有在代理对象上执行这些操作才会触发捕获器。在目标对象上执行这些操作仍然会产生正
常的行为**。



```js
const target = {
    foo: 'bar'
};
const handler = {
    // 捕获器在处理程序对象中以方法名为键
    get() {
        return 'handler override';
    }
};
const proxy = new Proxy(target, handler);
console.log(target.foo); // bar
console.log(proxy.foo); // handler override
console.log(target['foo']); // bar
console.log(proxy['foo']); // handler override
console.log(Object.create(target)['foo']); // bar
console.log(Object.create(proxy)['foo']); // handler override
```



## 捕获器参数和反射API

所有捕获器都可以访问相应的参数，基于这些参数可以重建被捕获方法的原始行为。比如，get()
捕获器会接收到目标对象、要查询的属性和代理对象三个参数。

```js
const target = {
    foo: 'bar'
};
const handler = {
    get(trapTarget, property, receiver) {
        console.log(trapTarget === target);
        console.log(property);
        console.log(receiver === proxy);
    }
};
const proxy = new Proxy(target, handler);
proxy.foo;
// true
// foo
// true
```





有了这些参数，就可以重建被捕获方法的原始行为：
```js
const target = {
    foo: 'bar'
};
const handler = {
    get(trapTarget, property, receiver) {
        return trapTarget[property];
    }
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```





所有捕获器都可以基于自己的参数重建原始操作，但并非所有捕获器行为都像get()那么简单。因此，通过手动写码如法炮制的想法是不现实的。实际上，**开发者并不需要手动重建原始行为，而是可以通过调用全局Reflect 对象上（封装了原始行为）的同名方法来轻松重建**。处理程序对象中所有可以捕获的方法都有对应的反射（Reflect）API 方法。这些方法与捕获器拦截的方法具有相同的名称和函数签名，而且也具有与被拦截方法相同的行为。因此，使用反射API 也可以
像下面这样定义出空代理对象：

```js
const target = {
    foo: 'bar'
};
const handler = {
    get() {
        return Reflect.get(...arguments);
    }
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```





甚至还可以写得更简洁一些：
```js
const target = {
    foo: 'bar'
};
const handler = {
    get: Reflect.get
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```





创建一个可以捕获所有方法，然后将每个方法转发给对应反射API 的空代理，那么甚至不需要定义处理程序对象：

```js

const target = {
    foo: 'bar'
};
const proxy = new Proxy(target, Reflect);
console.log(proxy.foo); // bar
console.log(target.foo); // bar
```



反射API 为开发者准备好了样板代码，在此基础上开发者可以用最少的代码修改捕获的方法。比如，
下面的代码在某个属性被访问时，会对返回的值进行一番修饰：

```js
const target = {
    foo: 'bar',
    baz: 'qux'
};
const handler = {
    get(trapTarget, property, receiver) {
        let decoration = '';
        if (property === 'foo') {
            decoration = '!!!';
        }
        return Reflect.get(...arguments) + decoration;
    }
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo); // bar!!!
console.log(target.foo); // bar
console.log(proxy.baz); // qux
console.log(target.baz); // qux
```

## 捕获器不变式



使用捕获器几乎可以改变所有基本方法的行为，但也不是没有限制。根据ECMAScript 规范，每个
捕获的方法都知道目标对象上下文、捕获函数签名，而捕获处理程序的行为必须遵循“捕获器不变式”
（trap invariant）。捕获器不变式因方法不同而异，但通常都会**防止捕获器定义出现过于反常的行为**。
比如，如果目标对象有一个不可配置且不可写的数据属性，那么在捕获器返回一个与该属性不同的
值时，会抛出TypeError：

```js
const target = {};
Object.defineProperty(target, 'foo', {
    configurable: false,
    writable: false,
    value: 'bar'
});
const handler = {
    get() {
        return 'qux';
    }
};
const proxy = new Proxy(target, handler);
console.log(proxy.foo);
// TypeError
```

## 可撤销代理

有时候可能需要**中断代理对象与目标对象之间的联系**。对于使用new Proxy()创建的普通代理来说，这种联系会在代理对象的生命周期内一直持续存在。Proxy 也暴露了revocable()方法，这个方法支持撤销代理对象与目标对象的关联。

**撤销代理的操作是不可逆的。而且，撤销函数（revoke()）是幂等的，调用多少次的结果都一样。撤销代理之后
再调用代理会抛出TypeError。**
撤销函数和代理对象是在实例化时同时生成的：

```js
const target = {
    foo: 'bar'
};
const handler = {
    get() {
        return 'intercepted';
    }
};
const { proxy, revoke } = Proxy.revocable(target, handler);
console.log(proxy.foo); // intercepted
console.log(target.foo); // bar
revoke();
console.log(proxy.foo); // TypeError
```





## 实用反射API





### 1.反射API与对象API

在使用反射API 时，要记住：
(1) 反射API 并不限于捕获处理程序；
(2) 大多数反射API 方法在Object 类型上有对应的方法。
通常，Object 上的方法适用于通用程序，而反射方法适用于细粒度的对象控制与操作。



### 2.状态标记

很多反射方法返回称作“状态标记”的布尔值，表示意图执行的操作是否成功。





使用反射API 对下面的代码进行重构：







```js
// 初始代码
const o = {};
try {
    Object.defineProperty(o, 'foo', 'bar');
    console.log('success');
} catch(e) {
    console.log('failure');
}
```



在定义新属性时如果发生问题，Reflect.defineProperty()会返回false，而不是抛出错误。

```js
// 初始代码
const o = {};
try {
    Object.defineProperty(o, 'foo', 'bar');
    console.log('success');
} catch(e) {
    console.log('failure');
}
```



以下反射方法都会提供状态标记：

- Reflect.defineProperty()
- Reflect.preventExtensions()
- Reflect.setPrototypeOf()
- Reflect.set()
- Reflect.deleteProperty()

### 3.用一等函数替代操作符
以下反射方法提供只有通过操作符才能完成的操作。

- Reflect.get()：可以替代对象属性访问操作符。
- Reflect.set()：可以替代=赋值操作符。
- Reflect.has()：可以替代in 操作符或with()。
- Reflect.deleteProperty()：可以替代delete 操作符。
- Reflect.construct()：可以替代new 操作符。



### 4.安全地应用函数

在通过apply 方法调用函数时，被调用的函数可能也定义了自己的apply 属性（虽然可能性极小）。
为绕过这个问题，可以使用定义在Function 原型上的apply 方法，比如：

```js
Function.prototype.apply.call(myFunc, thisVal, argumentList);
```



可以使用Reflect.apply 来避免：

```js
Reflect.apply(myFunc, thisVal, argumentsList);
```







## 代理另一个代理

代理可以拦截反射API的操作，而这意味着完全可以创建一个代理，通过它去代理另一个代理。这
样就可以在一个目标对象之上构建多层拦截网：

```js
const target = {
    foo: 'bar'
};
const firstProxy = new Proxy(target, {
    get() {
        console.log('first proxy');
        return Reflect.get(...arguments);
    }
});
const secondProxy = new Proxy(firstProxy, {
    get() {
        console.log('second proxy');
        return Reflect.get(...arguments);
    }
});
console.log(secondProxy.foo);
// second proxy
// first proxy
// bar
```









## 代理的问题与不足



### 代理中的this









# 代理捕获器和反射方法

https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Proxy/Proxy/get

















# 代理模式
使用代理可以在代码中实现一些有用的编程模式。



## 跟踪属性访问

通过捕获get、set 和has 等操作，可以知道对象属性什么时候被访问、被查询。把实现相应捕获器的某个对象代理放到应用中，可以监控这个对象何时在何处被访问过：

```js
const user = {
	name: 'Jake'
};
const proxy = new Proxy(user, {
	get(target, property, receiver) {
		console.log(`Getting ${property}`);
		return Reflect.get(...arguments);
	},
	set(target, property, value, receiver) {
        console.log(`Setting ${property}=${value}`);
        return Reflect.set(...arguments);
	}
});
proxy.name; // Getting name
proxy.age = 27; // Setting age=27
```







## 隐藏属性
代理的内部实现对外部代码是不可见的，因此要隐藏目标对象上的属性也轻而易举



```js
const hiddenProperties = ['foo', 'bar'];
const targetObject = {
    foo: 1,
    bar: 2,
    baz: 3
};
const proxy = new Proxy(targetObject, {
    get(target, property) {
        if (hiddenProperties.includes(property)) {
            return undefined;
        } else {
            return Reflect.get(...arguments);
        }
    },
    has(target, property) {
    	if (hiddenProperties.includes(property)) {
        	return false;
        } else {
            return Reflect.has(...arguments);
        }
    }
});
// get()
console.log(proxy.foo); // undefined
console.log(proxy.bar); // undefined
console.log(proxy.baz); // 3
// has()
console.log('foo' in proxy); // false
console.log('bar' in proxy); // false
console.log('baz' in proxy); // true
    
```





## 属性验证
因为所有赋值操作都会触发set()捕获器，所以可以根据所赋的值决定是允许还是拒绝赋值：

```js
const target = {
	onlyNumbersGoHere: 0
};
const proxy = new Proxy(target, {
	set(target, property, value) {
        if (typeof value !== 'number') {
            return false;
        } else {
            return Reflect.set(...arguments);
        }
    }
});
proxy.onlyNumbersGoHere = 1;
console.log(proxy.onlyNumbersGoHere); // 1
proxy.onlyNumbersGoHere = '2';
console.log(proxy.onlyNumbersGoHere); // 1
```





## 函数与构造函数参数验证

跟保护和验证对象属性类似，也可对函数和构造函数参数进行审查。比如，可以让函数只接收某种
类型的值：

```js
function median(...nums) {
	return nums.sort()[Math.floor(nums.length / 2)];
}
const proxy = new Proxy(median, {
    apply(target, thisArg, argumentsList) {
    	for (const arg of argumentsList) {
    		if (typeof arg !== 'number') {
    			throw 'Non-number argument provided';
    		}
    	}
    	return Reflect.apply(...arguments);
	}
});
console.log(proxy(4, 7, 1)); // 4
console.log(proxy(4, '7', 1));
// Error: Non-number argument provided
```



类似地，可以要求实例化时必须给构造函数传参：

```js
class User {
	constructor(id) {
		this.id_ = id;
	}
}
const proxy = new Proxy(User, {
    construct(target, argumentsList, newTarget) {
        if (argumentsList[0] === undefined) {
        	throw 'User cannot be instantiated without id';
        } else {
        	return Reflect.construct(...arguments);
        }
    }
});
new proxy(1);
new proxy();// Error: User cannot be instantiated without id
```













## 数据绑定和可观察对象

通过代理可以把运行时中原本不相关的部分联系到一起。这样就可以实现各种模式，从而让不同的
代码互操作。
比如，可以将被代理的类绑定到一个全局实例集合，让所有创建的实例都被添加到这个集合中：



```js
const userList = [];
class User {
  constructor(name) {
    this.name_ = name;
  }
}
const proxy = new Proxy(User, {
  construct () {
    const newUser = Reflect.construct(...arguments);
    userList.push(newUser);
    return newUser;
  }
});
new proxy('John');
new proxy('Jacob');
new proxy('Jingleheimerschmidt');
console.log(userList); // [User {}, User {}, User{}]
```





另外，还可以把集合绑定到一个事件分派程序，每次插入新实例时都会发送消息：

```js
const userList = [];
function emit(newValue) {
	console.log(newValue);
}
const proxy = new Proxy(userList, {
    set(target, property, value, receiver) {
    	const result = Reflect.set(...arguments);
        if (result) {
        	emit(Reflect.get(target, property, receiver));
        }
        return result;
	}
});
proxy.push('John');// John
proxy.push('Jacob');// Jacob
```











从宏观上看，代理是真实JavaScript 对象的透明抽象层。代理可以定义包含捕获器的处理程序对象，而这些捕获器可以拦截绝大部分JavaScript 的基本操作和方法。在这个捕获器处理程序中，可以修改任何基本操作的行为，当然前提是遵从捕获器不变式。