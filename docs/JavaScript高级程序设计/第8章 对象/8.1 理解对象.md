



## 什么是对象

ECMA-262 将对象定义为**一组属性的无序集合**。严格来说，这意味着对象就是一组没有特定顺序的
值。对象的每个属性或方法都由一个名称来标识，这个名称映射到一个值。正因为如此（以及其他还未
讨论的原因），可以把 ECMAScript 的对象想象成一张散列表，其中的内容就是一组名/值对，值可以是
数据或者函数。  



## 如何创建对象

- 使用构造函数Object

```js
let person = new Object();
person.name = "Nicholas";
person.age = 29;
person.job = "Software Engineer";
person.sayName = function() {
    console.log(this.name);
};  
```

- 使用对象字面量：

```js
let person = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    }
};  
```



## 8.1.1 属性的类型





### 数据属性

数据属性包含一个保存数据值的位置。值会从这个位置读取，也会写入到这个位置。数据属性有 4
个特性描述它们的行为。

- [[Configurable]]：**表示属性是否可以通过 delete 删除并重新定义，是否可以修改它的特
  性，以及是否可以把它改为访问器属性**。默认情况下，所有直接定义在对象上的属性的这个特
  性都是 true，如前面的例子所示。

  

-  [[Enumerable]]：**表示属性是否可以通过 for-in 循环返回**。默认情况下，所有直接定义在对
  象上的属性的这个特性都是 true，如前面的例子所示。

  

- [[Writable]]：**表示属性的值是否可以被修改**。默认情况下，所有直接定义在对象上的属性的
  这个特性都是 true，如前面的例子所示。

  

- [[Value]]：**包含属性实际的值**。这就是前面提到的那个读取和写入属性值的位置。这个特性
  的默认值为 undefined。

  

  在像前面例子中那样将属性显式添加到对象之后， [[Configurable]]、 [[Enumerable]]和

  [[Writable]]都会被设置为 true，而[[Value]]特性会被设置为指定的值。  



要修改属性的默认特性，就必须使用Object.defineProperty()方法。这个方法接收3 个参数：
要给其添加属性的对象、属性的名称和一个描述符对象。最后一个参数，即描述符对象上的属性可以包
含：configurable、enumerable、writable 和value，跟相关特性的名称一一对应。根据要修改
的特性，可以设置其中一个或多个值。







```js
let person = {
    name: "Nicholas",
    age: 29,
    job: "Software Engineer",
    sayName() {
        console.log(this.name);
    },
};
Object.defineProperty(person, "name", {
    writable: false,
    value: "Nicholas",
});
console.log(person.name); // "Nicholas"
person.name = "Greg";
console.log(person.name); // "Nicholas"
```



创建了一个名为name 的属性并给它赋予了一个只读的值"Nicholas"。这个属性的值就
不能再修改了，**在非严格模式下尝试给这个属性重新赋值会被忽略**。**在严格模式下，尝试修改只读属性
的值会抛出错误**













```js
let person = {};
Object.defineProperty(person, "name", {
    configurable: false,
    value: "Nicholas"
});
console.log(person.name); // "Nicholas"
delete person.name;
console.log(person.name); // "Nicholas"
```



这个例子把configurable 设置为false，意味着这个属性不能从对象上删除。非严格模式下对
这个属性调用delete 没有效果，严格模式下会抛出错误。

此外，**一个属性被定义为不可配置之后，就不能再变回可配置的了**。再次调用Object.defineProperty()并修改任何非writable 属性会导致错误：

```js
let person = {};
Object.defineProperty(person, "name", {
configurable: false,
value: "Nicholas"
});
// 抛出错误
Object.defineProperty(person, "name", {
configurable: true,
value: "Nicholas"
});
```







虽然可以对同一个属性多次调用Object.defineProperty()，但在把configurable 设置为false 之后就会受限制了

**在调用Object.defineProperty()时，configurable、enumerable 和writable 的值如果不
指定，则都默认为false。**



### 访问器属性



访问器属性不包含数据值。相反，它们包含一个获取（ getter）函数和一个设置（ setter）函数，不
过这两个函数不是必需的。在读取访问器属性时，会调用获取函数，这个函数的责任就是返回一个有效
的值。在写入访问器属性时，会调用设置函数并传入新值，这个函数必须决定对数据做出什么修改。访
问器属性有 4 个特性描述它们的行为。

- [[Configurable]]：**表示属性是否可以通过 delete 删除并重新定义**，是否可以修改它的特
  性，以及是否可以把它改为数据属性。默认情况下，所有直接定义在对象上的属性的这个特性
  都是 true。
- [[Enumerable]]：**表示属性是否可以通过 for-in 循环返回**。默认情况下，所有直接定义在对
  象上的属性的这个特性都是 true。
- [[Get]]：获取函数，在**读取属性时调用**。默认值为 undefined。
- [[Set]]：设置函数，在**写入属性时调用**。默认值为 undefined。





**访问器属性是不能直接定义的，必须使用 Object.defineProperty()**。  

```js
// 定义一个对象，包含伪私有成员year_和公共成员edition
let book = {
    year_: 2017,
    edition: 1
};
Object.defineProperty(book, "year", {
    get() {
        return this.year_;
    },
    set(newValue) {
        if (newValue > 2017) {
            this.year_ = newValue;
            this.edition += newValue - 2017;
        }
    }
});
book.year = 2018;
console.log(book.edition); // 2
```





获取函数和设置函数不一定都要定义。**只定义获取函数意味着属性是只读的，尝试修改属性会被忽
略。在严格模式下，尝试写入只定义了获取函数的属性会抛出错误**。类似地，**只有一个设置函数的属性
是不能读取的，非严格模式下读取会返回undefined，严格模式下会抛出错误**。
在不支持Object.defineProperty()的浏览器中没有办法修改[[Configurable]]或[[Enumerable]]



## 8.1.2 定义多个属性

Object.defineProperties()可以通过多个描述符一次性定义多个属性

```js
let book = {};
Object.defineProperties(book, {
  year_: {
    value: 2017,
  },
  edition: {
    value: 1,
  },
  year: {
    get() {
      return this.year_;
    },
    set(newValue) {
      if (newValue > 2017) {
        this.year_ = newValue;
        this.edition += newValue - 2017;
      }
    },
  },
});

```





## 8.1.3 读取属性的特性

使用Object.getOwnPropertyDescriptor()方法可以取得指定属性的属性描述符。这个方法接
收两个参数：属性所在的对象和要取得其描述符的属性名。

返回值是一个对象:

- 对于访问器属性包含configurable、enumerable、get 和set 属性
- 对于数据属性包含configurable、enumerable、writable 和value 属性。



```js
let book = {};
Object.defineProperties(book, {
    year_: {
        value: 2017
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
            return this.year_;
        },
        set: function(newValue){
            if (newValue > 2017) {
                this.year_ = newValue;
                this.edition += newValue - 2017;
            }
        }
    }
});
let descriptor = Object.getOwnPropertyDescriptor(book, "year_");
console.log(descriptor.value); // 2017
console.log(descriptor.configurable); // false
console.log(typeof descriptor.get); // "undefined"
let descriptor = Object.getOwnPropertyDescriptor(book, "year");
console.log(descriptor.value); // undefined
console.log(descriptor.enumerable); // false
console.log(typeof descriptor.get); // "function"
```



对于数据属性year_，value 等于原来的值，configurable 是false，get 是undefined。对
于访问器属性year，value 是undefined，enumerable 是false，get 是一个指向获取函数的指针。



ECMAScript 2017 新增了Object.getOwnPropertyDescriptors()静态方法。这个方法实际上
会在每个自有属性上调用Object.getOwnPropertyDescriptor()并在一个新对象中返回它们。对于
前面的例子，使用这个静态方法会返回如下对象：



```js
let book = {};
Object.defineProperties(book, {
    year_: {
        value: 2017
    },
    edition: {
        value: 1
    },
    year: {
        get: function() {
            return this.year_;
        },
        set: function(newValue){
            if (newValue > 2017) {
                this.year_ = newValue;
                this.edition += newValue - 2017;
            }
        }
    }
});
console.log(Object.getOwnPropertyDescriptors(book));

// {
// edition: {
// configurable: false,
// enumerable: false,
// value: 1,
// writable: false
// },
// year: {
// configurable: false,
// enumerable: false,
// get: f(),
// set: f(newValue),
// },
// year_: {
// configurable: false,
// enumerable: false,
// value: 2017,
// writable: false
// }
// }
```





## 8.1.4 合并对象



```js
let dest, src, result;
/**
\* 简单复制
*/
dest = {};
src = { id: "src" };
result = Object.assign(dest, src);
// Object.assign 修改目标对象
// 也会返回修改后的目标对象
console.log(dest === result); // true
console.log(dest !== src); // true
console.log(result); // { id: src }
console.log(dest); // { id: src }
/**
\* 多个源对象
*/
dest = {};
result = Object.assign(dest, { a: "foo" }, { b: "bar" });
console.log(result); // { a: foo, b: bar }
/**
\* 获取函数与设置函数
*/
dest = {
    set a(val) {
        console.log(`Invoked dest setter with param ${val}`);
    },
};
src = {
    get a() {
        console.log("Invoked src getter");
        return "foo";
    },
};
Object.assign(dest, src);
// 调用 src 的获取方法
// 调用 dest 的设置方法并传入参数"foo"
// 因为这里的设置函数不执行赋值操作
// 所以实际上并没有把值转移过来
console.log(dest); // { set a(val) {...} }

```

**Object.assign()实际上对每个源对象执行的是浅复制**。如果多个源对象都有相同的属性，则后面同名属性的会覆盖前面的。此外，从源对象访问器属性取得的值，比如获取函数，会作为一个静态值赋给目标对象。换句话说，不能在两个对象间转移获取函数和设置函数。  



## 8.1.5 对象标识及相等判定

在ECMAScript 6 之前，有些特殊情况即使是===操作符也无能为力：

```js
// 这些是===符合预期的情况
console.log(true === 1); // false
console.log({} === {}); // false
console.log("2" === 2); // false
// 这些情况在不同JavaScript 引擎中表现不同，但仍被认为相等
console.log(+0 === -0); // true
console.log(+0 === 0); // true
console.log(-0 === 0); // true
// 要确定NaN 的相等性，必须使用极为讨厌的isNaN()
console.log(NaN === NaN); // false
console.log(isNaN(NaN)); // true
```

为改善这类情况，ECMAScript 6 规范新增了Object.is()，这个方法与===很像，但同时也考虑
到了上述边界情形。这个方法必须接收两个参数：

```js
console.log(Object.is(true, 1)); // false
console.log(Object.is({}, {})); // false
console.log(Object.is("2", 2)); // false
// 正确的0、-0、+0 相等/不等判定
console.log(Object.is(+0, -0)); // false
console.log(Object.is(+0, 0)); // true
console.log(Object.is(-0, 0)); // false
// 正确的NaN 相等判定
console.log(Object.is(NaN, NaN)); // true
```





要检查超过两个值，递归地利用相等性传递即可：

```js
function recursivelyCheckEqual(x, ...rest) {
    return Object.is(x, rest[0]) &&
        (rest.length < 2 || recursivelyCheckEqual(...rest));
}
```







## 8.1.6 增强的对象语法



### 属性值简写

在给对象添加变量的时候，当属性名和变量名是一样的

```js
let name = 'Matt';
let person = {
    name: name
};
console.log(person); // { name: 'Matt' }
```

可以使用简写属性名语法：

```js
let name = 'Matt';
let person = {
name
};
console.log(person); // { name: 'Matt' }
```







### 可计算属性

在引入可计算属性之前，如果想使用变量的值作为属性，那么必须先声明对象，然后使用中括号语法来添加属性,即不能在对象字面量中直接动态命名属性

```js
const nameKey = 'name';
const ageKey = 'age';
const jobKey = 'job';
let person = {};
person[nameKey] = 'Matt';
person[ageKey] = 27;
person[jobKey] = 'Software engineer';
console.log(person); // { name: 'Matt', age: 27, job: 'Software engineer' }
```





有了可计算属性，就可以在对象字面量中完成动态属性赋值。



```js
const nameKey = 'name';
const ageKey = 'age';
const jobKey = 'job';
let person = {
    [nameKey]: 'Matt',
    [ageKey]: 27,
    [jobKey]: 'Software engineer'
};
console.log(person); // { name: 'Matt', age: 27, job: 'Software engineer' }
```



可计算属性本身可以是复杂的表达式，在实例化时再求值:

```js
const nameKey = 'name';
const ageKey = 'age';
const jobKey = 'job';
let uniqueToken = 0;
function getUniqueKey(key) {
    return `${key}_${uniqueToken++}`;
}
let person = {
    [getUniqueKey(nameKey)]: 'Matt',
    [getUniqueKey(ageKey)]: 27,
    [getUniqueKey(jobKey)]: 'Software engineer'
};
console.log(person); // { name_0: 'Matt', age_1: 27, job_2: 'Software engineer' }
```





## 8.1.7 对象解构



ECMAScript 6 新增了对象解构语法，可以在一条语句中使用嵌套数据实现一个或多个赋值操作。简
单地说，**对象解构就是使用与对象匹配的结构来实现对象属性赋值**  



- 不使用对象解构:

```js
let person = {
    name: 'Matt',
    age: 27
};
let personName = person.name,
    personAge = person.age;
console.log(personName); // Matt
console.log(personAge); // 27
```

- 使用对象解构

```js
let person = {
    name: 'Matt',
    age: 27
};
let { name: personName, age: personAge } = person;
console.log(personName); // Matt
console.log(personAge); // 27
```





使用解构，可以在一个类似对象字面量的结构中，声明多个变量，同时执行多个赋值操作。

如果想**让变量直接使用属性的名称，那么可以使用简写语法**:



```js
let person = {
    name: 'Matt',
    age: 27
};
let { name, age } = person;
console.log(name); // Matt
console.log(age); // 27
```



**解构赋值不一定与对象的属性匹配**。赋值的时候可以忽略某些属性，而如果引用的属性不存在，则
该变量的值就是undefined：

```js
let person = {
    name: 'Matt',
    age: 27
};
let { name, job } = person;
console.log(name); // Matt
console.log(job); // undefined
```





也**可以在解构赋值的同时定义默认值**，这适用于前面刚提到的引用的属性不存在于源对象中的
情况：

```js
let person = {
    name: 'Matt',
    age: 27
};
let { name, job='Software engineer' } = person;
console.log(name); // Matt
console.log(job); // Software engineer
```





解构在内部使用函数ToObject()（不能在运行时环境中直接访问）把源数据结构转换为对象。这
意味着**在对象解构的上下文中，原始值会被当成对象**。这也意味着（根据ToObject()的定义），**null
和undefined 不能被解构，否则会抛出错误**。

```js
let { length } = 'foobar';
console.log(length); // 6
let { constructor: c } = 4;
console.log(c === Number); // true
let { _ } = null; // TypeError
let { _ } = undefined; // TypeError
```





**解构并不要求变量必须在解构表达式中声明**。不过，如果是**给事先声明的变量赋值，则赋值表达式
必须包含在一对括号中**：

```js
let personName, personAge;
let person = {
    name: 'Matt',
    age: 27
};
({name: personName, age: personAge} = person);
console.log(personName, personAge); // Matt, 27
```







### 1. 嵌套解构
解构对于引用嵌套的属性或赋值目标没有限制。为此，可以通过解构来复制对象属性：



```js
let person = {
    name: 'Matt',
    age: 27,
    job: {
        title: 'Software engineer'
    }
};
let personCopy = {};
({
    name: personCopy.name,
    age: personCopy.age,
    job: personCopy.job
} = person);
// 因为一个对象的引用被赋值给personCopy，所以修改
// person.job 对象的属性也会影响personCopy
person.job.title = 'Hacker'
console.log(person);
// { name: 'Matt', age: 27, job: { title: 'Hacker' } }
console.log(personCopy);
// { name: 'Matt', age: 27, job: { title: 'Hacker' } }
```















解构赋值可以使用嵌套结构，以**匹配嵌套的属性**：

```js
let person = {
    name: 'Matt',
    age: 27,
    job: {
        title: 'Software engineer'
    }
};
// 声明title 变量并将person.job.title 的值赋给它
let { job: { title } } = person;
console.log(title); // Software engineer
```



在外层属性没有定义的情况下不能使用嵌套解构。无论源对象还是目标对象都一样：

```js
let person = {
    job: {
        title: 'Software engineer'
    }
};
let personCopy = {};
// foo 在源对象上是undefined
({
    foo: {
        bar: personCopy.bar
    }
} = person);
// TypeError: Cannot destructure property 'bar' of 'undefined' or 'null'.
// job 在目标对象上是undefined
({
    job: {
        title: personCopy.job.title
    }
} = person);
// TypeError: Cannot set property 'title' of undefined
```





### 2. 部分解构

需要注意的是，涉及多个属性的解构赋值是一个输出无关的顺序化操作。**如果一个解构表达式涉及多个赋值，开始的赋值成功而后面的赋值出错，则整个解构赋值只会完成一部分**：

```js
let person = {
    name: 'Matt',
    age: 27
};
let personName, personBar, personAge;
try {
    // person.foo 是undefined，因此会抛出错误
    ({name: personName, foo: { bar: personBar }, age: personAge} = person);
} catch(e) {

}
console.log(personName, personBar, personAge);
// Matt, undefined, undefined
```









### 3. 参数上下文匹配
在**函数参数列表中也可以进行解构赋值。对参数的解构赋值不会影响arguments 对象**，可以在函数体中使用解构的变量。



```js
let person = {
    name: 'Matt',
    age: 27
};
function printPerson(foo, {name, age}, bar) {
    console.log(arguments);
    console.log(name, age);
}
function printPerson2(foo, {name: personName, age: personAge}, bar) {
    console.log(arguments);
    console.log(personName, personAge);
}
printPerson('1st', person, '2nd');
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
printPerson2('1st', person, '2nd');
// ['1st', { name: 'Matt', age: 27 }, '2nd']
// 'Matt', 27
```

