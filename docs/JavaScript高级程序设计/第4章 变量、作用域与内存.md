# 4.1 原始值和引用值

ECMAScript 变量可以包含两种不同类型的数据：原始值和引用值。 原始值（ primitive value）就是
最简单的数据， 引用值（ reference value）则是由多个值构成的对象。  

操作原始值时，操作的就是存储在变量中的实际值  

操作对象时，实际上操作的是对该对象的引用  

**保存原始值的变量是按值（ by value）访问的 ** 

**保存引用值的变量是按引用（ by reference）访问的 ** 





## 动态属性

对于引用值而言，可以随时添加、修改和删除其属性和方法。  

```js
let person = new Object();
person.name = "Nicholas";
console.log(person.name); // "Nicholas"
```



原始值不能有属性，尽管尝试给原始值添加属性不会报错  

```js
let name = "Nicholas";
name.age = 27;
console.log(name.age); // undefined
```



**只有引用值可以动态添加后面可以使用的属性**







## 复制值

除了存储方式不同，原始值和引用值在通过变量复制时也有所不同。

在通过变量把一个原始值赋值到另一个变量时，原始值会被复制到新变量的位置 ,这两个变量可以独立使用，互不干扰  

在把引用值从一个变量赋给另一个变量时，存储在变量中的值也会被复制到新变量所在的位置。区别在于，这里**复制的值实际上是一个指针，它指向存储在堆内存中的对象**。操作完成后，两个变量实际上指向同一个对象  

```js
let obj1 = new Object();
let obj2 = obj1;
obj1.name = "Nicholas"; 
console.log(obj2.name); // "Nicholas" 
console.log(obj1 === obj2); // true
```









## 传递参数  

**ECMAScript 中所有函数的参数都是按值传递的。**  

这意味着函数外的值会被复制到函数内部的参数
中，就像从一个变量复制到另一个变量一样。如果是原始值，那么就跟原始值变量的复制一样，如果是
引用值，那么就跟引用值变量的复制一样。  



```js
function addTen(num) {
    num += 10;
	return num;
}
let count = 20;
let result = addTen(count);
console.log(count); // 20，没有变化
```





```js
function setName(obj) {
obj.name = "Nicholas";
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas
```



为了证明对象时按值传递的：

```js
function setName(obj) {
    obj.name = "Nicholas";
    obj = new Object();
    obj.name = "Greg";
}
let person = new Object();
setName(person);
console.log(person.name); // "Nicholas"
```



如果person 是按引用传递的，那么person 应该自动将指针改为指向name 为"Greg"的对象。

可是，当我们再次访问person.name 时，它的值是"Nicholas"，这表明函数中参数的值改变之后，原始的引用仍然没变。当obj 在函数内部被重写时，它变成了一个指向本地对象的指针。而那个本地对象在函数执行结束时就被销毁了。



## 确定类型



### typeof

> **`typeof`** 运算符返回一个字符串，表示操作数的类型。

```js
let s = "Nicholas";
let b = true;
let i = 22;
let u;
let n = null;
let o = new Object();
console.log(typeof s); // string
console.log(typeof i); // number
console.log(typeof b); // boolean
console.log(typeof u); // undefined
console.log(typeof n); // object
console.log(typeof o); // object
```



### instanceof

>**`instanceof`** **运算符**用于检测构造函数的 `prototype` 属性是否出现在某个实例对象的原型链上。



按照定义，所有引用值都是Object 的实例，因此通过instanceof 操作符检测任何引用值和Object 构造函数都会返回true。类似地，如果用instanceof 检测原始值，则始终会返回false，因为原始值不是对象。

```js
let person = {};
let colors = [];
let pattern = /a*/;
console.log(person instanceof Object); // 变量person 是Object 吗？
console.log(colors instanceof Array); // 变量colors 是Array 吗？
console.log(pattern instanceof RegExp); // 变量pattern 是RegExp 吗？
```







引用链接：

[typeof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/typeof)

[instanceof](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/instanceof)



# 4.2 执行上下文与作用域

