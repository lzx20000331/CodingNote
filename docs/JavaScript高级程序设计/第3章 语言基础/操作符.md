# 一元操作符

只操作一个值的操作符叫一元操作符

## 递增/递减操作符

递增和递减操作符直接照搬自C 语言，但有两个版本：前缀版和后缀版



无论使用前缀递增还是前缀递减操作符，变量的值都会在语句被求值之前改变

```js
let age = 29;
let anotherAge = --age + 2;
console.log(age); // 28
console.log(anotherAge); // 30
```



后缀版递增和递减在语句被求值后变量才发生改变

```js
let num1 = 2;
let num2 = 20;
let num3 = num1-- + num2;
let num4 = num1 + num2;
console.log(num3); // 22
console.log(num4); // 21
```







这4 个操作符可以作用于任何值，意思是不限于整数——字符串、布尔值、浮点值，甚至对象都可以。

**通常是先转换为数值形式，再应用改变**

递增和递减操作符遵循如下规则
. 对于字符串，如果是有效的数值形式，则转换为数值再应用改变。变量类型从字符串变成数值
. 对于字符串，如果不是有效的数值形式，则将变量的值设置为NaN 。变量类型从字符串变成数值
. 对于布尔值，如果是false，则转换为0 再应用改变。变量类型从布尔值变成数值
. 对于布尔值，如果是true，则转换为1 再应用改变。变量类型从布尔值变成数值
. 对于浮点值，加1 或减1
. 如果是对象，则调用其valueOf()方法取得可以操作的值。对得到的值应用上述规则。如果是NaN，则调用toString()并再次应用其他规则。



```js
let s1 = "2";
let s2 = "z";
let b = false;
let f = 1.1;
let o = {
    valueOf() {
        return -1;
    }
};
s1++; // 值变成数值3
s2++; // 值变成NaN
b++; // 值变成数值1
f--; // 值变成0.10000000000000009（因为浮点数不精确）
o--; // 值变成-2
```









## 一元加和减

一元加由一个加号（+）表示，放在变量前头，对数值没有任何影响：
```js
let num = 25;
num = +num;
console.log(num); // 25
```



一元加应用到非数值，则会执行与使转型函数一样的类型转换Number(）：

布尔值false和true 转换为0 和1，

字符串根据特殊规则进行解析

对象会调用它们的valueOf()和/或toString()
方法以得到可以转换的值

```js
let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
valueOf() {
return -1;
}
};
s1 = +s1; // 值变成数值1
s2 = +s2; // 值变成数值1.1
s3 = +s3; // 值变成NaN
b = +b; // 值变成数值0
f = +f; // 不变，还是1.1
o = +o; // 值变成数值-1
```







一元减由一个减号（-）表示，放在变量前头，主要用于把数值变成负值，如把1 转换为-1。示例
如下：

```js
let num = 25;
num = -num;
console.log(num); // -25
```





在应用到非数值时，一元减会遵循与一元加同样的规则，先对它们进行转换，然后再取负

```js
let s1 = "01";
let s2 = "1.1";
let s3 = "z";
let b = false;
let f = 1.1;
let o = {
    valueOf() {
        return -1;
    }
};
s1 = -s1; // 值变成数值-1
s2 = -s2; // 值变成数值-1.1
s3 = -s3; // 值变成NaN
b = -b; // 值变成数值0
f = -f; // 变成-1.1
o = -o; // 值变成数值1
```



# 位操作符

位操作符用于操作内存中表示数据的比特位



## 按位非

按位非操作符用波浪符（~）表示，它的作用是返回数值的一补数



```js
let num1 = 25; // 二进制00000000000000000000000000011001
let num2 = ~num1; // 二进制11111111111111111111111111100110
console.log(num2); // -26
```





## 按位与





## 按位或



## 左移





## 有符号右移

## 无符号右移





# 布尔操作符

## 逻辑非

**逻辑非**（`!`，逻辑连接取反）运算符将真值或假值转换为对应的相反值，经常用于布尔（逻辑）值。当与非布尔值使用时，如果其操作数可以转化为 `true`，则返回 `false`，否则返回 `true`。





逻辑非操作符首先将操作数转换为布尔值，然后再对其取反。换
句话说，逻辑非操作符会遵循如下规则。

- 如果操作数是对象，则返回false。
- 如果操作数是空字符串，则返回true。
- 如果操作数是非空字符串，则返回false。
- 如果操作数是数值0，则返回true。
- 如果操作数是非0 数值（包括Infinity），则返回false。
- 如果操作数是null，则返回true。
- 如果操作数是NaN，则返回true。
- 如果操作数是undefined，则返回true。



```js
console.log(!false); // true
console.log(!"blue"); // false
console.log(!0); // true
console.log(!NaN); // true
console.log(!""); // true
console.log(!12345); // false
```







双非运算符（`!!`）

同时使用两个叹号（!!），相当于调用了转型函数Boolean()。无论操作数是什么类型，第一个叹号总会返回布尔值。第二个叹号对该布尔值取反

```js
console.log(!!"blue"); // true
console.log(!!0); // false
console.log(!!NaN); // false
console.log(!!""); // false
console.log(!!12345); // true
```









## 逻辑与

逻辑与操作符可用于任何类型的操作数，不限于布尔值。如果有操作数不是布尔值，则逻辑与并不
一定会返回布尔值，而是遵循如下规则:

- 如果第一个操作数是对象，则返回第二个操作数。
- 如果第二个操作数是对象，则只有第一个操作数求值为true 才会返回该对象。
- 如果两个操作数都是对象，则返回第二个操作数。
- 如果有一个操作数是null，则返回null。
- 如果有一个操作数是NaN，则返回NaN。
- 如果有一个操作数是undefined，则返回undefined。

逻辑与操作符是一种短路操作符，意思就是**如果第一个操作数决定了结果，那么永远不会对第二个
操作数求值**。对逻辑与操作符来说，如果第一个操作数是false，那么无论第二个操作数是什么值，结
果也不可能等于true。



## 逻辑或

逻辑或操作符由两个管道符（||）表示

```js
let result = true || false;
```





如果有一个操作数不是布尔值，那么逻辑或操作符也不一定返回布尔值。它遵循如
下规则。

- 如果第一个操作数是对象，则返回第一个操作数。

- 如果第一个操作数求值为false，则返回第二个操作数。

- 如果两个操作数都是对象，则返回第一个操作数。

- 如果两个操作数都是null，则返回null。

- 如果两个操作数都是NaN，则返回NaN。

- 如果两个操作数都是undefined，则返回undefined。

  同样与逻辑与类似，逻辑或操作符也具有短路的特性。只不过对逻辑或而言，**第一个操作数求值为
  true，第二个操作数就不会再被求值了。**

```js
let found = true;
let result = (found || someUndeclaredVariable); // 不会出错
console.log(result); // 会执行
```



```js
let found = false;
let result = (found || someUndeclaredVariable); // 这里会出错
console.log(result); // 不会执行这一行
```



利用这个行为，可以避免给变量赋值null 或undefined。比如：
```
let myObject = preferredObject || backupObject;
```





# *乘性操作符



## 乘法操作符

乘法操作符由一个星号（*）表示，可以用于计算两个数值的乘积。

```js
let result = 34 * 56;
```



- 如果操作数都是数值，则执行常规的乘法运算，即两个正值相乘是正值，两个负值相乘也是正
  值，正负符号不同的值相乘得到负值。如果ECMAScript 不能表示乘积，则返回Infinity 或
  -Infinity。

- 如果有任一操作数是NaN，则返回NaN。
- 如果是Infinity 乘以0，则返回NaN。
- 如果是Infinity 乘以非0 的有限数值，则根据第二个操作数的符号返回Infinity 或-Infinity。
- 如果是Infinity 乘以Infinity，则返回Infinity。
- 如果有不是数值的操作数，则先在后台用Number()将其转换为数值，然后再应用上述规则。

## 除法操作符



除法操作符由一个斜杠（/）表示，用于计算第一个操作数除以第二个操作数的商，比如：

```JS
let result = 66 / 11;
```



跟乘法操作符一样，除法操作符针对特殊值也有一些特殊的行为。

- 如果操作数都是数值，则执行常规的除法运算，即两个正值相除是正值，两个负值相除也是正
  值，符号不同的值相除得到负值。如果ECMAScript不能表示商，则返回Infinity 或-Infinity。
- 如果有任一操作数是NaN，则返回NaN。
- 如果是Infinity 除以Infinity，则返回NaN。
- 如果是0 除以0，则返回NaN。
- 如果是非0 的有限值除以0，则根据第一个操作数的符号返回Infinity 或-Infinity。
- 如果是Infinity 除以任何数值，则根据第二个操作数的符号返回Infinity 或-Infinity。
- 如果有不是数值的操作数，则先在后台用Number()函数将其转换为数值，然后再应用上述规则。



```js
  console.log(10 / 2); //5
  console.log(9.0 / 3); //3
  console.log(10 / NaN); //NaN
  console.log(NaN / 10); //NaN
  console.log(Infinity / Infinity); //NaN
  console.log(0 / 0); //NaN
  console.log(10 / 0); //Infinity
  console.log(-10 / 0); //-Infinity
  console.log(Infinity / 10); //Infinity
  console.log(Infinity / -10); //-Infinity
  console.log("8" / "2"); //4
  console.log("-9" / 3); //-3
  console.log(4 / "2"); //2
```







## 取余操作符

取模（余数）操作符由一个百分比符号（%）表示，比如：

```js
let result = 26 % 5; // 等于1
```





与其他乘性操作符一样，取模操作符对特殊值也有一些特殊的行为。

- 如果操作数是数值，则执行常规除法运算，返回余数。
- 如果被除数是无限值，除数是有限值，则返回NaN。
- 如果被除数是有限值，除数是0，则返回NaN。
- 如果是Infinity 除以Infinity，则返回NaN。
- 如果被除数是有限值，除数是无限值，则返回被除数。
- 如果被除数是0，除数不是0，则返回0。
- 如果有不是数值的操作数，则先在后台用Number()函数将其转换为数值，然后再应用上述规则。





```JS
console.log(10 % 6); //4
console.log(Infinity % 10); //NaN
console.log(10 % 0); //NaN
console.log(Infinity % Infinity); //NaN
console.log(10 % Infinity); //10
console.log(0 % 10); //0
console.log("10" % 6); //4
console.log(10 % "6"); //4
console.log("10" % "6"); //4
```







# 指数操作符

ECMAScript 7 新增了指数操作符，Math.pow()现在有了自己的操作符**，结果是一样的

```js
console.log(Math.pow(3, 2); // 9
console.log(3 ** 2); // 9
console.log(Math.pow(16, 0.5); // 4
console.log(16** 0.5); // 4
```



不仅如此，指数操作符也有自己的指数赋值操作符**=，该操作符执行指数运算和结果的赋值操作：

```js
let squared = 3;
squared **= 2;
console.log(squared); // 9
let sqrt = 16;
sqrt **= 0.5;
console.log(sqrt); // 4
```



# 加性操作符

加性操作符，即加法和减法操作符.

## 

## 加法操作符



如果两个操作数都是数值，加法操作符执行加法运算并根据如下规则返回结果：

- 如果有任一操作数是NaN，则返回NaN；
- 如果是Infinity 加Infinity，则返回Infinity；
- 如果是-Infinity 加-Infinity，则返回-Infinity；
- **如果是Infinity 加-Infinity，则返回NaN**；
- 如果是+0 加+0，则返回+0；
- **如果是-0 加+0，则返回+0**；
- 如果是-0 加-0，则返回-0。
  不过，如果有一个操作数是字符串，则要应用如下规则：
  - 如果两个操作数都是字符串，则将第二个字符串拼接到第一个字符串后面；
  - 如果只有一个操作数是字符串，则将另一个操作数转换为字符串，再将两个字符串拼接在一起。

如果有任一操作数是对象、数值或布尔值，则调用它们的toString()方法以获取字符串，然后再
应用前面的关于字符串的规则。对于undefined 和null，则调用String()函数，分别获取
"undefined"和"null"。

```js
console.log(NaN + 1);//NaN
console.log(Infinity + Infinity);//Infinity
console.log(-Infinity + -Infinity);//-Infinity
console.log(Infinity + -Infinity);//NaN
console.log(+0 + +0);//0
console.log(+0 + -0);//0
console.log(-0 + -0);//-0
console.log(1 + '234');//'1234'
console.log('123' + 4);//'1234'
console.log(Infinity + -Infinity + '123' + Infinity + -Infinity);//'NaN123Infinity-Infinity'
let o = {
    valueOf () {
        return 99
    }
}
console.log(o + 1);//100
console.log(o + '1');//'991'

```





## 减法操作符



与加法操作符一样，减法操作符也有一组规则用于处理ECMAScript 中不同类型之间的转换。



- 如果两个操作数都是数值，则执行数学减法运算并返回结果。
- 如果有任一操作数是NaN，则返回NaN。
- **如果是Infinity 减Infinity，则返回NaN**。
- **如果是-Infinity 减-Infinity，则返回NaN**。
- 如果是Infinity 减-Infinity，则返回Infinity。
- 如果是-Infinity 减Infinity，则返回-Infinity。
- 如果是+0 减+0，则返回+0。
- **如果是+0 减-0，则返回-0**。
- **如果是-0 减-0，则返回+0**。
   如果有任一操作数是字符串、布尔值、null 或undefined，则先在后台使用Number()将其转
  换为数值，然后再根据前面的规则执行数学运算。如果转换结果是NaN，则减法计算的结果是
  NaN。
   如果有任一操作数是对象，则调用其valueOf()方法取得表示它的数值。如果该值是NaN，则
  减法计算的结果是NaN。如果对象没有valueOf()方法，则调用其toString()方法，然后再
  将得到的字符串转换为数值





# 关系操作符

关系操作符执行比较两个值的操作，包括小于（<）、大于（>）、小于等于（<=）和大于等于（>=），
用法跟数学课上学的一样。这几个操作符都返回布尔值



- 如果操作数都是数值，则执行数值比较。

- 如果有任一操作数是布尔值，则将其转换为数值再执行比较。

- 如果有任一操作数是数值，则将另一个操作数转换为数值，执行数值比较。

- **如果操作数都是字符串，则逐个比较字符串中对应字符的编码**。

- 如果有任一操作数是对象，则调用其valueOf()方法，取得结果后再根据前面的规则执行比较。

- 如果没有valueOf()操作符，则调用toString()方法，取得结果后再根据前面的规则执行比较。






在比较两个数值字符串的时候：

```js
let result = "23" < "3"; // true
```

这里在比较字符串"23"和"3"时返回true。因为两个操作数都是字符串，所以会逐个比较它们的
字符编码（字符"2"的编码是50，而字符"3"的编码是51）。



不过，如果有一个操作数是数值，那么比较的结果就对了：

```js
let result = "23" < 3; // false
```

因为这次会将字符串"23"转换为数值23，然后再跟3 比较





任何关系操作符在涉及比较NaN 时都返回false

```js
let result1 = NaN < 3; // false
let result2 = NaN >= 3; // false
```





# *相等操作符

## 相等和不相等

ECMAScript 中的等于操作符用两个等于号（==）表示，如果操作数相等，则会返回true。不等于
操作符用叹号和等于号（!=）表示，如果两个操作数不相等，则会返回true。这两个操作符都会先进
行类型转换（通常称为强制类型转换）再确定操作数是否相等。

相等运算符（`==` 和 `!=`）提供[非严格相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#非严格相等)语义。这可以大致总结如下：

1. 如果操作数具有相同的类型，则按如下方式进行比较：
   - 对象（Object）：仅当两个操作数引用同一个对象时返回 `true`。
   - 字符串（String）：只有当两个操作数具有相同的字符且顺序相同时才返回 `true`。
   - 数值（Number）：如果两个操作数的值相同，则返回 `true`。`+0` 和 `-0` 被视为相同的值。如果任何一个操作数是 `NaN`，返回 `false`；所以，`NaN` 永远不等于 `NaN`。
   - 布尔值（Boolean）：仅当操作数都为 `true` 或都为 `false` 时返回 `true`。
   - 大整形（BigInt）：仅当两个操作数值相同时返回 `true`。
   - 符号（Symbol）：仅当两个操作数引用相同的符号时返回 `true`。
2. 如果其中一个操作数为 `null` 或 `undefined`，另一个操作数也必须为 `null` 或 `undefined` 以返回 `true`。否则返回 `false`。
3. 如果其中一个操作数是对象，另一个是基本类型，按此顺序使用对象的 [`@@toPrimitive()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Symbol/toPrimitive)（以 `"default"` 作为提示），[`valueOf()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/valueOf) 和 [`toString()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Object/toString) 方法将对象转换为基本类型。（这个基本类型转换与[相加](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Addition)中使用的转换相同。）
4. 在这一步，两个操作数都被转换为基本类型（String、Number、Boolean、Symbol 和 BigInt 中的一个）。其余的转换是逐个进行的。
   - 如果是相同的类型，使用步骤 1 进行比较。
   - 如果其中一个操作数是 Symbol 而另一个不是，返回 `false`。
   - 如果其中一个操作数是布尔型而另一个不是，则将布尔型转换为数字：`true` 转换为 1，`false` 转换为 0。然后再次松散地比较两个操作数。
   - Number to String：使用与 [`Number()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/Number/Number) 构造函数相同的算法将字符串转换为数字。转换失败将导致 `NaN`，这将保证相等是 `false`。
   - Number to BigInt：按数值进行比较。如果数值为 ±∞ 或 `NaN`，返回 `false`。
   - String to BigInt：使用与 [`BigInt()`](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Global_Objects/BigInt/BigInt) 构造函数相同的算法将字符串转换为 BigInt。如果转换失败，返回 `false`。

宽松相等是*对称的*：`A == B` 对于 `A` 和 `B` 的任何值总是具有与 `B == A` 相同的语义（应用转换的顺序除外）。

该运算符与[严格相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Strict_equality)（`===`）运算符之间最显著的区别是，严格相等运算符不尝试类型转换。相反，严格相等运算符总是认为不同类型的操作数是不同的。严格相等运算符本质上只执行第 1 步，然后对所有其他情况返回 `false`。





## 全等和不全等

严格相等运算符（`===` 和 `!==`）提供了[严格相等判定](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Equality_comparisons_and_sameness#严格相等)语义。

- 如果操作数的类型不同，则返回 `false`。
- 如果两个操作数都是对象，只有当它们指向同一个对象时才返回 `true`。
- 如果两个操作数都为 `null`，或者两个操作数都为 `undefined`，返回 `true`。
- 如果两个操作数有任意一个为 `NaN`，返回 `false`。
- 否则，比较两个操作数的值：
  - 数字类型必须拥有相同的数值。`+0` 和 `-0` 会被认为是相同的值。
  - 字符串类型必须拥有相同顺序的相同字符。
  - 布尔运算符必须同时为 `true` 或同时为 `false`。
  
  

严格相等运算符与[相等](https://developer.mozilla.org/zh-CN/docs/Web/JavaScript/Reference/Operators/Equality)（`==`）运算符最显著的区别是，如果操作数的类型不同，`==` 运算符会在比较之前尝试将它们转换为相同的类型。





# 条件操作符



即三元运算符

```js
variable = boolean_expression ? true_value : false_value;
```

如果boolean_expression 是true ， 则赋值true_value ；

如果 boolean_expression 是false，则赋值false_value。

比如：

```js
let max = (num1 > num2) ? num1 : num2;
```



在这个例子中，max 将被赋予一个最大值。这个表达式的意思是，如果num1 大于num2（条件表
达式为true），则将num1 赋给max。否则，将num2 赋给max。





# 赋值运算符

简单赋值用等于号（=）表示，将右手边的值赋给左手边的变量，如下所示：

```js
let num = 10;
```



复合赋值使用乘性、加性或位操作符后跟等于号（=）表示。这些赋值操作符是类似如下常见赋值
操作的简写形式：

```js
let num = 10;
num = num + 10;
```



以上代码的第二行可以通过复合赋值来完成：

```js
let num = 10;
num += 10;
```


每个数学操作符以及其他一些操作符都有对应的复合赋值操作符：

- 乘后赋值（*=）

- 除后赋值（/=）

- 取模后赋值（%=）

- 加后赋值（+=）

- 减后赋值（-=）

- 左移后赋值（<<=）

- 右移后赋值（>>=）

- 无符号右移后赋值（>>>=）

  这些操作符仅仅是简写语法，使用它们不会提升性能。



# 逗号操作符



**逗号操作符可以用来在一条语句中执行多个操作**，如下所示：

```js
let num1 = 1, num2 = 2, num3 = 3;
```

在一条语句中同时声明多个变量是逗号操作符最常用的场景。不过，也可以使用逗号操作符来辅助
赋值**。**在赋值时使用逗号操作符分隔值，最终会返回表达式中最后一个值**：

```js
let num = (5, 1, 4, 8, 0); 
```

num 的值为0在这个例子中，num 将被赋值为0，因为0 是表达式中最后一项。逗号操作符的这种使用场景并不
多见，但这种行为的确存在。













