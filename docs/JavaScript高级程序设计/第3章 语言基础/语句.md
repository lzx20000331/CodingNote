# if



语法：

```js
if (condition) statement1 else statement2
```



（condition）可以是任何表达式，并且求值结果不一定是布尔值。ECMAScript 会自
动调用Boolean()函数将这个表达式的值转换为布尔值。

如果条件求值为true，则执行语句statement1；如果条件求值为false，则执行语句statement2







可以像这样连续使用多个if 语句：

```js
if (condition1) statement1 else if (condition2) statement2 else statement3
```





下面是一个例子：

```js
if (i > 25) {
console.log("Greater than 25.");
} else if (i < 0) {
console.log("Less than 0.");
} else {
```





# do while



do-while 语句是一种后测试循环语句，即循环体中的代码执行后才会对退出条件进行求值。换句
话说，循环体内的代码至少执行一次。

```js
    let i = 1;
    do {
      i += 10; //先执行
    } while (i < 1); //后判断
    console.log(i); //11
```







# while



while 语句是一种先测试循环语句，即先检测退出条件，再执行循环体内的代码。因此，while 循
环体内的代码有可能不会执行。



```js
let i = 0;
while (i < 10) {
i += 2;
}
```





# for

```js
let count = 10;
for (let i = 0; i < count; i++) {
console.log(i);
}
```





等价于

```js
let count = 10;
let i = 0;
while (i < count) {
console.log(i);
i++;
}
```







# for in

for-in 语句是一种严格的迭代语句，用于枚举对象中的非符号键属性，语法如下：

```js
for (property in expression) statement
```



使用for-in 循环显示了BOM 对象window 的所有属性。每次执行循环，都会给变量propName 赋予一个window 对象的属性作为值，直到window 的所有属性都被枚举一遍。

```js

for (const propName in window) {
document.write(propName);
}
```



ECMAScript 中对象的属性是无序的，因此for-in 语句不能保证返回对象属性的顺序。换句话说，所有可枚举的属性都会返回一次，但返回的顺序可能会因浏览器而异。

**如果for-in 循环要迭代的变量是null 或undefined，则不执行循环体**。

# for of

for-of 语句是一种严格的迭代语句，用于遍历可迭代对象的元素，语法如下：

```js
for (property of expression) statement
```



下面是示例：

```js
for (const el of [2,4,6,8]) {
document.write(el);
}
```



在这个例子中，我们使用for-of 语句显示了一个包含4 个元素的数组中的所有元素。循环会一直
持续到将所有元素都迭代完。与for 循环一样，这里控制语句中的const 也不是必需的。但为了确保
这个局部变量不被修改，推荐使用const。



**for-of 循环会按照可迭代对象的next()方法产生值的顺序迭代元素。**

**如果尝试迭代的变量不支持迭代，则for-of 语句会抛出错误。**



- ES2018 对for-of 语句进行了扩展，增加了for-await-of 循环，以支持生成期约（promise）的异步可迭代对象。



# 标签语句

标签语句用于给语句加标签，语法如下：

```js
label: statement
```



下面是一个例子：

```js
start: for (let i = 0; i < count; i++) {
console.log(i);
}
```




在这个例子中，start 是一个标签，可以在后面通过break 或continue 语句引用。标签语句的
典型应用场景是嵌套循环。



# break continue

break 和continue 语句为执行循环代码提供了更严格的控制手段。其中，break 语句用于立即退
出循环，强制执行循环后的下一条语句。而continue 语句也用于立即退出循环，但会再次从循环顶部
开始执行。下面看一个例子：

```js
let num = 0;
for (let i = 1; i < 10; i++) {
    if (i % 5 == 0) {
        break;
    }
    num++;
}
console.log(num); // 4
```





在上面的代码中，for 循环会将变量i 由1 递增到10。而在循环体内，有一个if 语句用于检查i
能否被5 整除（使用取模操作符）。如果是，则执行break 语句，退出循环。变量num 的初始值为0，
表示循环在退出前执行了多少次。当break 语句执行后，下一行执行的代码是console.log(num)，
显示4。之所以循环执行了4 次，是因为当i 等于5 时，break 语句会导致循环退出，该次循环不会执
行递增num 的代码。



如果将break 换成continue，则会出现不同的效果：

```js
let num = 0;
for (let i = 1; i < 10; i++) {
    if (i % 5 == 0) {
        continue;
    }
    num++;
}
console.log(num); // 8
```



这一次，console.log 显示8，即循环被完整执行了8 次。当i 等于5 时，循环会在递增num 之
前退出，但会执行下一次迭代，此时i 是6。然后，循环会一直执行到自然结束，即i 等于10。最终
num 的值是8 而不是9，是因为continue 语句导致它少递增了一次。





break 和continue 都可以与标签语句一起使用，返回代码中特定的位置。这通常是在嵌套循环中



```js
let num = 0;
outermost:
for (let i = 0; i < 10; i++) {
for (let j = 0; j < 10; j++) {
if (i == 5 && j == 5) {
break outermost;
}
num++;
}
}
console.log(num); // 55
```





```js
let num = 0;
outermost:
for (let i = 0; i < 10; i++) {
    for (let j = 0; j < 10; j++) {
        if (i == 5 && j == 5) {
            continue outermost;
        }
        num++;
    }
}
console.log(num); // 95
```







# *with



**with 语句的用途是将代码作用域设置为特定的对象**，其语法是：

```js
with (expression) statement;
```



使用with 语句的主要场景是针对一个对象反复操作，这时候将代码作用域设置为该对象能提供便
利，如下面的例子所示：

```js
let qs = location.search.substring(1);
let hostName = location.hostname;
let url = location.href;
```





上面代码中的每一行都用到了location 对象。如果使用with 语句，就可以少写一些代码：

```js
with(location) {
    let qs = search.substring(1);
    let hostName = hostname;
    let url = href;
}
```





这里，with 语句用于连接location 对象。这意味着在这个语句内部，每个变量首先会被认为是
一个局部变量。如果没有找到该局部变量，则会搜索location 对象，看它是否有一个同名的属性。如
果有，则该变量会被求值为location 对象的属性。





**严格模式不允许使用with 语句，否则会抛出错误。**





# switch语句



switch 语句是与if 语句紧密相关的一种流控制语句



```js
switch (expression) {
    case value1:
        statementbreak;
    case value2:
        statement
        break;
    case value3:
        statement
        break;
    case value4:
        statement
        break;
    default:
        statement
}
```





有了switch 语句，开发者就用不着写类似这样的代码了：

```js
if (i == 25) {
    console.log("25");
} else if (i == 35) {
    console.log("35");
} else if (i == 45) {
    console.log("45");
} else {
    console.log("Other");
}
```





而是可以这样写：

```js
switch (i) {
    case 25:
        console.log("25");
        break;
    case 35:
        console.log("35");
        break;
    case 45:
        console.log("45");
        break;
    default:
        console.log("Other");
}
```





如果确实需要连续匹配几个
条件，那么推荐写个注释表明是故意忽略了break，如下所示：



```js
switch (i) {
    case 25:
        /*跳过*/
    case 35:
        console.log("25 or 35");
        break;
    case 45:
        console.log("45");
        break;
    default:
        console.log("Other");
}
```







**switch 语句可以用于所有数据类型**，因此可以使用字符串甚至对象。
其次，条件的值不需要是常量，也可以是变量或表达式。看下面的例子：

```js
switch ("hello world") {
    case "hello" + " world":
        console.log("Greeting was found.");
        break;
    case "goodbye":
        console.log("Closing was found.");
        break;
    default:
        console.log("Unexpected message was found.");
}
```





能够在条件判断中使用表达式，就可以在判断中加入更多逻辑：

```js
let num = 25;
switch (true) {
    case num < 0:
        console.log("Less than 0.");
        break;
    case num >= 0 && num <= 10:
        console.log("Between 0 and 10.");
        break;
    case num > 10 && num <= 20:
        console.log("Between 10 and 20.");
        break;
    default:
        console.log("More than 20.");
}

```





**switch 语句在比较每个条件的值时会使用全等操作符，因此不会强制转换数据类型**